{
   "bar_index ⇨ 𝑥": {
      "prefix": "bar_index",
      "body": [
         "bar_index$0"
      ],
      "description": "Current bar index. Numbering is zero-based, index of the first bar is 0. | TYPE series int"
   },
   "barstate.isconfirmed ⇨ 𝑥": {
      "prefix": "barstate.isconfirmed",
      "body": [
         "barstate.isconfirmed$0"
      ],
      "description": "Returns true if the script is calculating the last (closing) update of the current bar. The next script calculation will be on the new bar data. | TYPE series bool"
   },
   "barstate.isfirst ⇨ 𝑥": {
      "prefix": "barstate.isfirst",
      "body": [
         "barstate.isfirst$0"
      ],
      "description": "Returns true if current bar is first bar in barset, false otherwise. | TYPE series bool"
   },
   "barstate.ishistory ⇨ 𝑥": {
      "prefix": "barstate.ishistory",
      "body": [
         "barstate.ishistory$0"
      ],
      "description": "Returns true if current bar is a historical bar, false otherwise. | TYPE series bool"
   },
   "barstate.islast ⇨ 𝑥": {
      "prefix": "barstate.islast",
      "body": [
         "barstate.islast$0"
      ],
      "description": "Returns true if current bar is the last bar in barset, false otherwise. This condition is true for all real-time bars in barset. | TYPE series bool"
   },
   "barstate.islastconfirmedhistory ⇨ 𝑥": {
      "prefix": "barstate.islastconfirmedhistory",
      "body": [
         "barstate.islastconfirmedhistory$0"
      ],
      "description": "Returns true if script is executing on the dataset's last bar when market is closed, or script is executing on the bar immediately preceding the real-time bar, if market is open. Returns false otherwise. | TYPE series bool"
   },
   "barstate.isnew ⇨ 𝑥": {
      "prefix": "barstate.isnew",
      "body": [
         "barstate.isnew$0"
      ],
      "description": "Returns true if script is currently calculating on new bar, false otherwise. This variable is true when calculating on historical bars or on first update of a newly generated real-time bar. | TYPE series bool"
   },
   "barstate.isrealtime ⇨ 𝑥": {
      "prefix": "barstate.isrealtime",
      "body": [
         "barstate.isrealtime$0"
      ],
      "description": "Returns true if current bar is a real-time bar, false otherwise. | TYPE series bool"
   },
   "box.all ⇨ 𝑥": {
      "prefix": "box.all",
      "body": [
         "box.all$0"
      ],
      "description": "Returns an array filled with all the current boxes drawn by the script. | TYPE box[]"
   },
   "chart.bg_color ⇨ 𝑥": {
      "prefix": "chart.bg_color",
      "body": [
         "chart.bg_color$0"
      ],
      "description": "Returns the color of the chart's background from the 'Chart settings/Appearance/Background' field. When a gradient is selected, the middle point of the gradient is returned. | TYPE input color"
   },
   "chart.fg_color ⇨ 𝑥": {
      "prefix": "chart.fg_color",
      "body": [
         "chart.fg_color$0"
      ],
      "description": "Returns a color providing optimal contrast with chart.bg_color. | TYPE input color"
   },
   "chart.is_heikinashi ⇨ 𝑥": {
      "prefix": "chart.is_heikinashi",
      "body": [
         "chart.is_heikinashi$0"
      ],
      "description": "Returns true if the chart type is Heikin Ashi, false otherwise. | TYPE simple bool"
   },
   "chart.is_kagi ⇨ 𝑥": {
      "prefix": "chart.is_kagi",
      "body": [
         "chart.is_kagi$0"
      ],
      "description": "Returns true if the chart type is Kagi, false otherwise. | TYPE simple bool"
   },
   "chart.is_linebreak ⇨ 𝑥": {
      "prefix": "chart.is_linebreak",
      "body": [
         "chart.is_linebreak$0"
      ],
      "description": "Returns true if the chart type is Line break, false otherwise. | TYPE simple bool"
   },
   "chart.is_pnf ⇨ 𝑥": {
      "prefix": "chart.is_pnf",
      "body": [
         "chart.is_pnf$0"
      ],
      "description": "Returns true if the chart type is Point & figure, false otherwise. | TYPE simple bool"
   },
   "chart.is_range ⇨ 𝑥": {
      "prefix": "chart.is_range",
      "body": [
         "chart.is_range$0"
      ],
      "description": "Returns true if the chart type is Range, false otherwise. | TYPE simple bool"
   },
   "chart.is_renko ⇨ 𝑥": {
      "prefix": "chart.is_renko",
      "body": [
         "chart.is_renko$0"
      ],
      "description": "Returns true if the chart type is Renko, false otherwise. | TYPE simple bool"
   },
   "chart.is_standard ⇨ 𝑥": {
      "prefix": "chart.is_standard",
      "body": [
         "chart.is_standard$0"
      ],
      "description": "Returns true if the chart type is bars, candles, hollow candles, line, area or baseline, false otherwise. | TYPE simple bool"
   },
   "chart.left_visible_bar_time ⇨ 𝑥": {
      "prefix": "chart.left_visible_bar_time",
      "body": [
         "chart.left_visible_bar_time$0"
      ],
      "description": "The time of the leftmost bar currently visible on the chart. | TYPE input int"
   },
   "chart.right_visible_bar_time ⇨ 𝑥": {
      "prefix": "chart.right_visible_bar_time",
      "body": [
         "chart.right_visible_bar_time$0"
      ],
      "description": "The time of the rightmost bar currently visible on the chart. | TYPE input int"
   },
   "close ⇨ 𝑥": {
      "prefix": "close",
      "body": [
         "close$0"
      ],
      "description": "Close price of the current bar when it has closed, or last traded price of a yet incomplete, realtime bar. | TYPE series float"
   },
   "dayofmonth ⇨ 𝑥": {
      "prefix": "dayofmonth",
      "body": [
         "dayofmonth$0"
      ],
      "description": "Date of current bar time in exchange timezone. | TYPE series int"
   },
   "dayofweek ⇨ 𝑥": {
      "prefix": "dayofweek",
      "body": [
         "dayofweek$0"
      ],
      "description": "Day of week for current bar time in exchange timezone. | TYPE series int"
   },
   "dividends.future_amount ⇨ 𝑥": {
      "prefix": "dividends.future_amount",
      "body": [
         "dividends.future_amount$0"
      ],
      "description": "Payment amount of upcoming dividend in currency of current instrument. | TYPE series float"
   },
   "dividends.future_ex_date ⇨ 𝑥": {
      "prefix": "dividends.future_ex_date",
      "body": [
         "dividends.future_ex_date$0"
      ],
      "description": "Ex-dividend date (Ex-date) of current instrument's next dividend payment. | TYPE series float"
   },
   "dividends.future_pay_date ⇨ 𝑥": {
      "prefix": "dividends.future_pay_date",
      "body": [
         "dividends.future_pay_date$0"
      ],
      "description": "Payment date (Pay date) of current instrument's next dividend payment. | TYPE series float"
   },
   "earnings.future_eps ⇨ 𝑥": {
      "prefix": "earnings.future_eps",
      "body": [
         "earnings.future_eps$0"
      ],
      "description": "Returns the estimated Earnings per Share of the next earnings report in the currency of the instrument, or na if this data isn't available. | TYPE series float"
   },
   "earnings.future_period_end_time ⇨ 𝑥": {
      "prefix": "earnings.future_period_end_time",
      "body": [
         "earnings.future_period_end_time$0"
      ],
      "description": "Checks the data for the next earnings report and returns the UNIX timestamp of the day when the financial period covered by those earnings ends, or na if this data isn't available. | TYPE series float"
   },
   "earnings.future_revenue ⇨ 𝑥": {
      "prefix": "earnings.future_revenue",
      "body": [
         "earnings.future_revenue$0"
      ],
      "description": "Returns the estimated Revenue of the next earnings report in the currency of the instrument, or na if this data isn't available. | TYPE series float"
   },
   "earnings.future_time ⇨ 𝑥": {
      "prefix": "earnings.future_time",
      "body": [
         "earnings.future_time$0"
      ],
      "description": "Returns a UNIX timestamp indicating the expected time of the next earnings report, or na if this data isn't available. | TYPE series float"
   },
   "high ⇨ 𝑥": {
      "prefix": "high",
      "body": [
         "high$0"
      ],
      "description": "Current high price. | TYPE series float"
   },
   "hl2 ⇨ 𝑥": {
      "prefix": "hl2",
      "body": [
         "hl2$0"
      ],
      "description": "Is a shortcut for (high + low)/2 | TYPE series float"
   },
   "hlc3 ⇨ 𝑥": {
      "prefix": "hlc3",
      "body": [
         "hlc3$0"
      ],
      "description": "Is a shortcut for (high + low + close)/3 | TYPE series float"
   },
   "hlcc4 ⇨ 𝑥": {
      "prefix": "hlcc4",
      "body": [
         "hlcc4$0"
      ],
      "description": "Is a shortcut for (high + low + close + close)/4 | TYPE series float"
   },
   "hour ⇨ 𝑥": {
      "prefix": "hour",
      "body": [
         "hour$0"
      ],
      "description": "Current bar hour in exchange timezone. | TYPE series int"
   },
   "label.all ⇨ 𝑥": {
      "prefix": "label.all",
      "body": [
         "label.all$0"
      ],
      "description": "Returns an array filled with all the current labels drawn by the script. | TYPE label[]"
   },
   "last_bar_index ⇨ 𝑥": {
      "prefix": "last_bar_index",
      "body": [
         "last_bar_index$0"
      ],
      "description": "Bar index of the last chart bar. Bar indices begin at zero on the first bar. | TYPE series int"
   },
   "last_bar_time ⇨ 𝑥": {
      "prefix": "last_bar_time",
      "body": [
         "last_bar_time$0"
      ],
      "description": "Time in UNIX format of the last chart bar. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. | TYPE series int"
   },
   "line.all ⇨ 𝑥": {
      "prefix": "line.all",
      "body": [
         "line.all$0"
      ],
      "description": "Returns an array filled with all the current lines drawn by the script. | TYPE line[]"
   },
   "linefill.all ⇨ 𝑥": {
      "prefix": "linefill.all",
      "body": [
         "linefill.all$0"
      ],
      "description": "Returns an array filled with all the current linefill objects drawn by the script. | TYPE linefill[]"
   },
   "low ⇨ 𝑥": {
      "prefix": "low",
      "body": [
         "low$0"
      ],
      "description": "Current low price. | TYPE series float"
   },
   "minute ⇨ 𝑥": {
      "prefix": "minute",
      "body": [
         "minute$0"
      ],
      "description": "Current bar minute in exchange timezone. | TYPE series int"
   },
   "month ⇨ 𝑥": {
      "prefix": "month",
      "body": [
         "month$0"
      ],
      "description": "Current bar month in exchange timezone. | TYPE series int"
   },
   "na ⇨ 𝑥": {
      "prefix": "na",
      "body": [
         "na$0"
      ],
      "description": "A keyword signifying 'not available', indicating that a variable has no assigned value. | TYPE simple na"
   },
   "ohlc4 ⇨ 𝑥": {
      "prefix": "ohlc4",
      "body": [
         "ohlc4$0"
      ],
      "description": "Is a shortcut for (open + high + low + close)/4 | TYPE series float"
   },
   "open ⇨ 𝑥": {
      "prefix": "open",
      "body": [
         "open$0"
      ],
      "description": "Current open price. | TYPE series float"
   },
   "polyline.all ⇨ 𝑥": {
      "prefix": "polyline.all",
      "body": [
         "polyline.all$0"
      ],
      "description": "Returns an array containing all current polyline instances drawn by the script. | TYPE polyline[]"
   },
   "second ⇨ 𝑥": {
      "prefix": "second",
      "body": [
         "second$0"
      ],
      "description": "Current bar second in exchange timezone. | TYPE series int"
   },
   "session.isfirstbar ⇨ 𝑥": {
      "prefix": "session.isfirstbar",
      "body": [
         "session.isfirstbar$0"
      ],
      "description": "Returns true if the current bar is the first bar of the day's session, `false` otherwise. If extended session information is used, only returns true on the first bar of the pre-market bars. | TYPE series bool"
   },
   "session.isfirstbar_regular ⇨ 𝑥": {
      "prefix": "session.isfirstbar_regular",
      "body": [
         "session.isfirstbar_regular$0"
      ],
      "description": "Returns true on the first regular session bar of the day, `false` otherwise. The result is the same whether extended session information is used or not. | TYPE series bool"
   },
   "session.islastbar ⇨ 𝑥": {
      "prefix": "session.islastbar",
      "body": [
         "session.islastbar$0"
      ],
      "description": "Returns true if the current bar is the last bar of the day's session, `false` otherwise. If extended session information is used, only returns true on the last bar of the post-market bars. | TYPE series bool"
   },
   "session.islastbar_regular ⇨ 𝑥": {
      "prefix": "session.islastbar_regular",
      "body": [
         "session.islastbar_regular$0"
      ],
      "description": "Returns true on the last regular session bar of the day, `false` otherwise. The result is the same whether extended session information is used or not. | TYPE series bool"
   },
   "session.ismarket ⇨ 𝑥": {
      "prefix": "session.ismarket",
      "body": [
         "session.ismarket$0"
      ],
      "description": "Returns true if the current bar is a part of the regular trading hours (i.e. market hours), false otherwise. | TYPE series bool"
   },
   "session.ispostmarket ⇨ 𝑥": {
      "prefix": "session.ispostmarket",
      "body": [
         "session.ispostmarket$0"
      ],
      "description": "Returns true if the current bar is a part of the post-market, false otherwise. On non-intraday charts always returns false. | TYPE series bool"
   },
   "session.ispremarket ⇨ 𝑥": {
      "prefix": "session.ispremarket",
      "body": [
         "session.ispremarket$0"
      ],
      "description": "Returns true if the current bar is a part of the pre-market, false otherwise. On non-intraday charts always returns false. | TYPE series bool"
   },
   "strategy.account_currency ⇨ 𝑥": {
      "prefix": "strategy.account_currency",
      "body": [
         "strategy.account_currency$0"
      ],
      "description": "Returns the currency used to calculate results, which can be set in the strategy's properties. | TYPE simple string"
   },
   "strategy.closedtrades ⇨ 𝑥": {
      "prefix": "strategy.closedtrades",
      "body": [
         "strategy.closedtrades$0"
      ],
      "description": "Number of trades, which were closed for the whole trading interval. | TYPE series int"
   },
   "strategy.equity ⇨ 𝑥": {
      "prefix": "strategy.equity",
      "body": [
         "strategy.equity$0"
      ],
      "description": "Current equity (strategy.initial_capital + strategy.netprofit + strategy.openprofit). | TYPE series float"
   },
   "strategy.eventrades ⇨ 𝑥": {
      "prefix": "strategy.eventrades",
      "body": [
         "strategy.eventrades$0"
      ],
      "description": "Number of breakeven trades for the whole trading interval. | TYPE series int"
   },
   "strategy.grossloss ⇨ 𝑥": {
      "prefix": "strategy.grossloss",
      "body": [
         "strategy.grossloss$0"
      ],
      "description": "Total currency value of all completed losing trades. | TYPE series float"
   },
   "strategy.grossloss_percent ⇨ 𝑥": {
      "prefix": "strategy.grossloss_percent",
      "body": [
         "strategy.grossloss_percent$0"
      ],
      "description": "The total value of all completed losing trades, expressed as a percentage of the initial capital. | TYPE series float"
   },
   "strategy.grossprofit ⇨ 𝑥": {
      "prefix": "strategy.grossprofit",
      "body": [
         "strategy.grossprofit$0"
      ],
      "description": "Total currency value of all completed winning trades. | TYPE series float"
   },
   "strategy.grossprofit_percent ⇨ 𝑥": {
      "prefix": "strategy.grossprofit_percent",
      "body": [
         "strategy.grossprofit_percent$0"
      ],
      "description": "The total currency value of all completed winning trades, expressed as a percentage of the initial capital. | TYPE series float"
   },
   "strategy.initial_capital ⇨ 𝑥": {
      "prefix": "strategy.initial_capital",
      "body": [
         "strategy.initial_capital$0"
      ],
      "description": "The amount of initial capital set in the strategy properties. | TYPE series float"
   },
   "strategy.long ⇨ 𝑥": {
      "prefix": "strategy.long",
      "body": [
         "strategy.long$0"
      ],
      "description": "Long position entry. | TYPE strategy_direction"
   },
   "strategy.losstrades ⇨ 𝑥": {
      "prefix": "strategy.losstrades",
      "body": [
         "strategy.losstrades$0"
      ],
      "description": "Number of unprofitable trades for the whole trading interval. | TYPE series int"
   },
   "strategy.margin_liquidation_price ⇨ 𝑥": {
      "prefix": "strategy.margin_liquidation_price",
      "body": [
         "strategy.margin_liquidation_price$0"
      ],
      "description": "When margin is used in a strategy, returns the price point where a simulated margin call will occur and liquidate enough of the position to meet the margin requirements. | TYPE series float"
   },
   "strategy.max_contracts_held_all ⇨ 𝑥": {
      "prefix": "strategy.max_contracts_held_all",
      "body": [
         "strategy.max_contracts_held_all$0"
      ],
      "description": "Maximum number of contracts/shares/lots/units in one trade for the whole trading interval. | TYPE series float"
   },
   "strategy.max_contracts_held_long ⇨ 𝑥": {
      "prefix": "strategy.max_contracts_held_long",
      "body": [
         "strategy.max_contracts_held_long$0"
      ],
      "description": "Maximum number of contracts/shares/lots/units in one long trade for the whole trading interval. | TYPE series float"
   },
   "strategy.max_contracts_held_short ⇨ 𝑥": {
      "prefix": "strategy.max_contracts_held_short",
      "body": [
         "strategy.max_contracts_held_short$0"
      ],
      "description": "Maximum number of contracts/shares/lots/units in one short trade for the whole trading interval. | TYPE series float"
   },
   "strategy.max_drawdown ⇨ 𝑥": {
      "prefix": "strategy.max_drawdown",
      "body": [
         "strategy.max_drawdown$0"
      ],
      "description": "Maximum equity drawdown value for the whole trading interval. | TYPE series float"
   },
   "strategy.max_drawdown_percent ⇨ 𝑥": {
      "prefix": "strategy.max_drawdown_percent",
      "body": [
         "strategy.max_drawdown_percent$0"
      ],
      "description": "The maximum equity drawdown value for the whole trading interval, expressed as a percentage and calculated by formula: Lowest Value During Trade / (Entry Price x Quantity) * 100. | TYPE series float"
   },
   "strategy.max_runup ⇨ 𝑥": {
      "prefix": "strategy.max_runup",
      "body": [
         "strategy.max_runup$0"
      ],
      "description": "Maximum equity run-up value for the whole trading interval. | TYPE series float"
   },
   "strategy.max_runup_percent ⇨ 𝑥": {
      "prefix": "strategy.max_runup_percent",
      "body": [
         "strategy.max_runup_percent$0"
      ],
      "description": "The maximum equity run-up value for the whole trading interval, expressed as a percentage and calculated by formula: Highest Value During Trade / (Entry Price x Quantity) * 100. | TYPE series float"
   },
   "strategy.netprofit ⇨ 𝑥": {
      "prefix": "strategy.netprofit",
      "body": [
         "strategy.netprofit$0"
      ],
      "description": "Total currency value of all completed trades. | TYPE series float"
   },
   "strategy.netprofit_percent ⇨ 𝑥": {
      "prefix": "strategy.netprofit_percent",
      "body": [
         "strategy.netprofit_percent$0"
      ],
      "description": "The total value of all completed trades, expressed as a percentage of the initial capital. | TYPE series float"
   },
   "strategy.openprofit ⇨ 𝑥": {
      "prefix": "strategy.openprofit",
      "body": [
         "strategy.openprofit$0"
      ],
      "description": "Current unrealized profit or loss for all open positions. | TYPE series float"
   },
   "strategy.openprofit_percent ⇨ 𝑥": {
      "prefix": "strategy.openprofit_percent",
      "body": [
         "strategy.openprofit_percent$0"
      ],
      "description": "The current unrealized profit or loss for all open positions, expressed as a percentage and calculated by formula: openPL / realizedEquity * 100. | TYPE series float"
   },
   "strategy.opentrades ⇨ 𝑥": {
      "prefix": "strategy.opentrades",
      "body": [
         "strategy.opentrades$0"
      ],
      "description": "Number of market position entries, which were not closed and remain opened. If there is no open market position, 0 is returned. | TYPE series int"
   },
   "strategy.position_avg_price ⇨ 𝑥": {
      "prefix": "strategy.position_avg_price",
      "body": [
         "strategy.position_avg_price$0"
      ],
      "description": "Average entry price of current market position. If the market position is flat, 'NaN' is returned. | TYPE series float"
   },
   "strategy.position_entry_name ⇨ 𝑥": {
      "prefix": "strategy.position_entry_name",
      "body": [
         "strategy.position_entry_name$0"
      ],
      "description": "Name of the order that initially opened current market position. | TYPE series string"
   },
   "strategy.position_size ⇨ 𝑥": {
      "prefix": "strategy.position_size",
      "body": [
         "strategy.position_size$0"
      ],
      "description": "Direction and size of the current market position. If the value is > 0, the market position is long. If the value is < 0, the market position is short. The absolute value is the number of contracts/shares/lots/units in trade (position size). | TYPE series float"
   },
   "strategy.short ⇨ 𝑥": {
      "prefix": "strategy.short",
      "body": [
         "strategy.short$0"
      ],
      "description": "Short position entry. | TYPE strategy_direction"
   },
   "strategy.wintrades ⇨ 𝑥": {
      "prefix": "strategy.wintrades",
      "body": [
         "strategy.wintrades$0"
      ],
      "description": "Number of profitable trades for the whole trading interval. | TYPE series int"
   },
   "syminfo.basecurrency ⇨ 𝑥": {
      "prefix": "syminfo.basecurrency",
      "body": [
         "syminfo.basecurrency$0"
      ],
      "description": "Base currency for the symbol. For the symbol 'BTCUSD' returns 'BTC'. | TYPE simple string"
   },
   "syminfo.country ⇨ 𝑥": {
      "prefix": "syminfo.country",
      "body": [
         "syminfo.country$0"
      ],
      "description": "Returns the two-letter code of the country where the symbol is traded, in the ISO 3166-1 alpha-2 format, or na if the exchange is not directly tied to a specific country. For example, on 'NASDAQ:AAPL' it will return 'US', on 'LSE:AAPL' it will return 'GB', and on 'BITSTAMP:BTCUSD' it will return na. | TYPE simple string"
   },
   "syminfo.currency ⇨ 𝑥": {
      "prefix": "syminfo.currency",
      "body": [
         "syminfo.currency$0"
      ],
      "description": "Currency for the current symbol. Returns currency code: 'USD', 'EUR', etc. | TYPE simple string"
   },
   "syminfo.description ⇨ 𝑥": {
      "prefix": "syminfo.description",
      "body": [
         "syminfo.description$0"
      ],
      "description": "Description for the current symbol. | TYPE simple string"
   },
   "syminfo.employees ⇨ 𝑥": {
      "prefix": "syminfo.employees",
      "body": [
         "syminfo.employees$0"
      ],
      "description": "The number of employees the company has. | TYPE simple int"
   },
   "syminfo.industry ⇨ 𝑥": {
      "prefix": "syminfo.industry",
      "body": [
         "syminfo.industry$0"
      ],
      "description": "Returns the industry of the symbol, or na if the symbol has no industry. Example: 'Internet Software/Services', 'Packaged software', 'Integrated Oil', 'Motor Vehicles', etc. These are the same values one can see in the chart's 'Symbol info' window. | TYPE simple string"
   },
   "syminfo.minmove ⇨ 𝑥": {
      "prefix": "syminfo.minmove",
      "body": [
         "syminfo.minmove$0"
      ],
      "description": "Returns a whole number used to calculate the smallest increment between a symbol's price movements (syminfo.mintick). It is the numerator in the syminfo.mintick formula. | TYPE simple int"
   },
   "syminfo.mintick ⇨ 𝑥": {
      "prefix": "syminfo.mintick",
      "body": [
         "syminfo.mintick$0"
      ],
      "description": "Min tick value for the current symbol. | TYPE simple float"
   },
   "syminfo.pointvalue ⇨ 𝑥": {
      "prefix": "syminfo.pointvalue",
      "body": [
         "syminfo.pointvalue$0"
      ],
      "description": "Point value for the current symbol. | TYPE simple float"
   },
   "syminfo.prefix ⇨ 𝑥": {
      "prefix": "syminfo.prefix",
      "body": [
         "syminfo.prefix$0"
      ],
      "description": "Prefix of current symbol name (i.e. for 'CME_EOD:TICKER' prefix is 'CME_EOD'). | TYPE simple string"
   },
   "syminfo.pricescale ⇨ 𝑥": {
      "prefix": "syminfo.pricescale",
      "body": [
         "syminfo.pricescale$0"
      ],
      "description": "Returns a whole number used to calculate the smallest increment between a symbol's price movements (syminfo.mintick). It is the denominator in the syminfo.mintick formula. | TYPE simple int"
   },
   "syminfo.recommendations_buy ⇨ 𝑥": {
      "prefix": "syminfo.recommendations_buy",
      "body": [
         "syminfo.recommendations_buy$0"
      ],
      "description": "The number of analysts who gave the current symbol a \"Buy\" rating. | TYPE series int"
   },
   "syminfo.recommendations_buy_strong ⇨ 𝑥": {
      "prefix": "syminfo.recommendations_buy_strong",
      "body": [
         "syminfo.recommendations_buy_strong$0"
      ],
      "description": "The number of analysts who gave the current symbol a \"Strong Buy\" rating. | TYPE series int"
   },
   "syminfo.recommendations_date ⇨ 𝑥": {
      "prefix": "syminfo.recommendations_date",
      "body": [
         "syminfo.recommendations_date$0"
      ],
      "description": "The starting date of the last set of recommendations for the current symbol. | TYPE series int"
   },
   "syminfo.recommendations_hold ⇨ 𝑥": {
      "prefix": "syminfo.recommendations_hold",
      "body": [
         "syminfo.recommendations_hold$0"
      ],
      "description": "The number of analysts who gave the current symbol a \"Hold\" rating. | TYPE series int"
   },
   "syminfo.recommendations_sell ⇨ 𝑥": {
      "prefix": "syminfo.recommendations_sell",
      "body": [
         "syminfo.recommendations_sell$0"
      ],
      "description": "The number of analysts who gave the current symbol a \"Sell\" rating. | TYPE series int"
   },
   "syminfo.recommendations_sell_strong ⇨ 𝑥": {
      "prefix": "syminfo.recommendations_sell_strong",
      "body": [
         "syminfo.recommendations_sell_strong$0"
      ],
      "description": "The number of analysts who gave the current symbol a \"Strong Sell\" rating. | TYPE series int"
   },
   "syminfo.recommendations_total ⇨ 𝑥": {
      "prefix": "syminfo.recommendations_total",
      "body": [
         "syminfo.recommendations_total$0"
      ],
      "description": "The total number of recommendations for the current symbol. | TYPE series int"
   },
   "syminfo.root ⇨ 𝑥": {
      "prefix": "syminfo.root",
      "body": [
         "syminfo.root$0"
      ],
      "description": "Root for derivatives like futures contract. For other symbols returns the same value as syminfo.ticker. | TYPE simple string"
   },
   "syminfo.sector ⇨ 𝑥": {
      "prefix": "syminfo.sector",
      "body": [
         "syminfo.sector$0"
      ],
      "description": "Returns the sector of the symbol, or na if the symbol has no sector. Example: 'Electronic Technology', 'Technology services', 'Energy Minerals', 'Consumer Durables', etc. These are the same values one can see in the chart's 'Symbol info' window. | TYPE simple string"
   },
   "syminfo.session ⇨ 𝑥": {
      "prefix": "syminfo.session",
      "body": [
         "syminfo.session$0"
      ],
      "description": "Session type of the chart main series. Possible values are session.regular, session.extended. | TYPE simple string"
   },
   "syminfo.shareholders ⇨ 𝑥": {
      "prefix": "syminfo.shareholders",
      "body": [
         "syminfo.shareholders$0"
      ],
      "description": "The number of shareholders the company has. | TYPE simple int"
   },
   "syminfo.shares_outstanding_float ⇨ 𝑥": {
      "prefix": "syminfo.shares_outstanding_float",
      "body": [
         "syminfo.shares_outstanding_float$0"
      ],
      "description": "The total number of shares outstanding a company has available, excluding any of its restricted shares. | TYPE simple float"
   },
   "syminfo.shares_outstanding_total ⇨ 𝑥": {
      "prefix": "syminfo.shares_outstanding_total",
      "body": [
         "syminfo.shares_outstanding_total$0"
      ],
      "description": "The total number of shares outstanding a company has available, including restricted shares held by insiders, major shareholders, and employees. | TYPE simple int"
   },
   "syminfo.target_price_average ⇨ 𝑥": {
      "prefix": "syminfo.target_price_average",
      "body": [
         "syminfo.target_price_average$0"
      ],
      "description": "The average of the last yearly price targets for the symbol predicted by analysts. | TYPE series float"
   },
   "syminfo.target_price_date ⇨ 𝑥": {
      "prefix": "syminfo.target_price_date",
      "body": [
         "syminfo.target_price_date$0"
      ],
      "description": "The starting date of the last price target prediction for the current symbol. | TYPE series int"
   },
   "syminfo.target_price_estimates ⇨ 𝑥": {
      "prefix": "syminfo.target_price_estimates",
      "body": [
         "syminfo.target_price_estimates$0"
      ],
      "description": "The latest total number of price target predictions for the current symbol. | TYPE series float"
   },
   "syminfo.target_price_high ⇨ 𝑥": {
      "prefix": "syminfo.target_price_high",
      "body": [
         "syminfo.target_price_high$0"
      ],
      "description": "The last highest yearly price target for the symbol predicted by analysts. | TYPE series float"
   },
   "syminfo.target_price_low ⇨ 𝑥": {
      "prefix": "syminfo.target_price_low",
      "body": [
         "syminfo.target_price_low$0"
      ],
      "description": "The last lowest yearly price target for the symbol predicted by analysts. | TYPE series float"
   },
   "syminfo.target_price_median ⇨ 𝑥": {
      "prefix": "syminfo.target_price_median",
      "body": [
         "syminfo.target_price_median$0"
      ],
      "description": "The median of the last yearly price targets for the symbol predicted by analysts. | TYPE series float"
   },
   "syminfo.ticker ⇨ 𝑥": {
      "prefix": "syminfo.ticker",
      "body": [
         "syminfo.ticker$0"
      ],
      "description": "Symbol name without exchange prefix, e.g. 'MSFT'. | TYPE simple string"
   },
   "syminfo.tickerid ⇨ 𝑥": {
      "prefix": "syminfo.tickerid",
      "body": [
         "syminfo.tickerid$0"
      ],
      "description": "Returns the full form of the ticker ID representing a symbol, for use as an argument in functions with a `ticker` or `symbol` parameter. It always includes the prefix (exchange) and ticker separated by a colon ('NASDAQ:AAPL'), but it can also include other symbol data such as dividend adjustment, chart type, currency conversion, etc. | TYPE simple string"
   },
   "syminfo.timezone ⇨ 𝑥": {
      "prefix": "syminfo.timezone",
      "body": [
         "syminfo.timezone$0"
      ],
      "description": "Timezone of the exchange of the chart main series. Possible values see in timestamp. | TYPE simple string"
   },
   "syminfo.type ⇨ 𝑥": {
      "prefix": "syminfo.type",
      "body": [
         "syminfo.type$0"
      ],
      "description": "Type of the current symbol. Possible values are stock, futures, index, forex, crypto, fund, dr. | TYPE simple string"
   },
   "syminfo.volumetype ⇨ 𝑥": {
      "prefix": "syminfo.volumetype",
      "body": [
         "syminfo.volumetype$0"
      ],
      "description": "Volume type of the current symbol. Possible values are: 'base' for base currency, 'quote' for quote currency, 'tick' for the number of transactions, and 'n/a' when there is no volume or its type is not specified. | TYPE simple string"
   },
   "ta.accdist ⇨ 𝑥": {
      "prefix": "ta.accdist",
      "body": [
         "ta.accdist$0"
      ],
      "description": "Accumulation/distribution index. | TYPE series float"
   },
   "ta.iii ⇨ 𝑥": {
      "prefix": "ta.iii",
      "body": [
         "ta.iii$0"
      ],
      "description": "Intraday Intensity Index. | TYPE series float"
   },
   "ta.nvi ⇨ 𝑥": {
      "prefix": "ta.nvi",
      "body": [
         "ta.nvi$0"
      ],
      "description": "Negative Volume Index. | TYPE series float"
   },
   "ta.obv ⇨ 𝑥": {
      "prefix": "ta.obv",
      "body": [
         "ta.obv$0"
      ],
      "description": "On Balance Volume. | TYPE series float"
   },
   "ta.pvi ⇨ 𝑥": {
      "prefix": "ta.pvi",
      "body": [
         "ta.pvi$0"
      ],
      "description": "Positive Volume Index. | TYPE series float"
   },
   "ta.pvt ⇨ 𝑥": {
      "prefix": "ta.pvt",
      "body": [
         "ta.pvt$0"
      ],
      "description": "Price-Volume Trend. | TYPE series float"
   },
   "ta.tr ⇨ 𝑥": {
      "prefix": "ta.tr",
      "body": [
         "ta.tr$0"
      ],
      "description": "True range. Same as tr(false). It is max(high - low, abs(high - close[1]), abs(low - close[1])) | TYPE series float"
   },
   "ta.vwap ⇨ 𝑥": {
      "prefix": "ta.vwap",
      "body": [
         "ta.vwap$0"
      ],
      "description": "Volume Weighted Average Price. It uses hlc3 as its source series. | TYPE series float"
   },
   "ta.wad ⇨ 𝑥": {
      "prefix": "ta.wad",
      "body": [
         "ta.wad$0"
      ],
      "description": "Williams Accumulation/Distribution. | TYPE series float"
   },
   "ta.wvad ⇨ 𝑥": {
      "prefix": "ta.wvad",
      "body": [
         "ta.wvad$0"
      ],
      "description": "Williams Variable Accumulation/Distribution. | TYPE series float"
   },
   "table.all ⇨ 𝑥": {
      "prefix": "table.all",
      "body": [
         "table.all$0"
      ],
      "description": "Returns an array filled with all the current tables drawn by the script. | TYPE table[]"
   },
   "time ⇨ 𝑥": {
      "prefix": "time",
      "body": [
         "time$0"
      ],
      "description": "Current bar time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. | TYPE series int"
   },
   "time_close ⇨ 𝑥": {
      "prefix": "time_close",
      "body": [
         "time_close$0"
      ],
      "description": "Current bar close time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. On price-based charts this variable value is na. | TYPE series int"
   },
   "time_tradingday ⇨ 𝑥": {
      "prefix": "time_tradingday",
      "body": [
         "time_tradingday$0"
      ],
      "description": "The beginning time of the trading day the current bar belongs to, in UNIX format (the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970). | TYPE series int"
   },
   "timeframe.isdaily ⇨ 𝑥": {
      "prefix": "timeframe.isdaily",
      "body": [
         "timeframe.isdaily$0"
      ],
      "description": "Returns true if current resolution is a daily resolution, false otherwise. | TYPE simple bool"
   },
   "timeframe.isdwm ⇨ 𝑥": {
      "prefix": "timeframe.isdwm",
      "body": [
         "timeframe.isdwm$0"
      ],
      "description": "Returns true if current resolution is a daily or weekly or monthly resolution, false otherwise. | TYPE simple bool"
   },
   "timeframe.isintraday ⇨ 𝑥": {
      "prefix": "timeframe.isintraday",
      "body": [
         "timeframe.isintraday$0"
      ],
      "description": "Returns true if current resolution is an intraday (minutes or seconds) resolution, false otherwise. | TYPE simple bool"
   },
   "timeframe.isminutes ⇨ 𝑥": {
      "prefix": "timeframe.isminutes",
      "body": [
         "timeframe.isminutes$0"
      ],
      "description": "Returns true if current resolution is a minutes resolution, false otherwise. | TYPE simple bool"
   },
   "timeframe.ismonthly ⇨ 𝑥": {
      "prefix": "timeframe.ismonthly",
      "body": [
         "timeframe.ismonthly$0"
      ],
      "description": "Returns true if current resolution is a monthly resolution, false otherwise. | TYPE simple bool"
   },
   "timeframe.isseconds ⇨ 𝑥": {
      "prefix": "timeframe.isseconds",
      "body": [
         "timeframe.isseconds$0"
      ],
      "description": "Returns true if current resolution is a seconds resolution, false otherwise. | TYPE simple bool"
   },
   "timeframe.isweekly ⇨ 𝑥": {
      "prefix": "timeframe.isweekly",
      "body": [
         "timeframe.isweekly$0"
      ],
      "description": "Returns true if current resolution is a weekly resolution, false otherwise. | TYPE simple bool"
   },
   "timeframe.multiplier ⇨ 𝑥": {
      "prefix": "timeframe.multiplier",
      "body": [
         "timeframe.multiplier$0"
      ],
      "description": "Multiplier of resolution, e.g. '60' - 60, 'D' - 1, '5D' - 5, '12M' - 12. | TYPE simple int"
   },
   "timeframe.period ⇨ 𝑥": {
      "prefix": "timeframe.period",
      "body": [
         "timeframe.period$0"
      ],
      "description": "A string representation of the chart's timeframe. The returned string's format is '[<quantity>][<units>]', where <quantity> and <units> are in some cases absent. <quantity> is the number of units, but it is absent if that number is 1. <unit> is 'S' for seconds, 'D' for days, 'W' for weeks, 'M' for months, but it is absent for minutes. No <unit> exists for hours. The variable will return: '10S' for 10 seconds, '60' for 60 minutes, 'D' for one day, '2W' for two weeks, '3M' for one quarter. Can be used as an argument with any function containing a `timeframe` parameter. | TYPE simple string"
   },
   "timenow ⇨ 𝑥": {
      "prefix": "timenow",
      "body": [
         "timenow$0"
      ],
      "description": "Current time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. | TYPE series int"
   },
   "volume ⇨ 𝑥": {
      "prefix": "volume",
      "body": [
         "volume$0"
      ],
      "description": "Current bar volume. | TYPE series float"
   },
   "weekofyear ⇨ 𝑥": {
      "prefix": "weekofyear",
      "body": [
         "weekofyear$0"
      ],
      "description": "Week number of current bar time in exchange timezone. | TYPE series int"
   },
   "year ⇨ 𝑥": {
      "prefix": "year",
      "body": [
         "year$0"
      ],
      "description": "Current bar year in exchange timezone. | TYPE series int"
   }
}