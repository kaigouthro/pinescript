{
    "adjustment.dividends ⇨ 𝑥": {
        "prefix": "adjustment.dividends",
        "body": [
            "adjustment.dividends$0"
        ],
        "description": "Constant for dividends adjustment type (dividends adjustment is applied). | TYPE const string"
    },
    "adjustment.none ⇨ 𝑥": {
        "prefix": "adjustment.none",
        "body": [
            "adjustment.none$0"
        ],
        "description": "Constant for none adjustment type (no adjustment is applied). | TYPE const string"
    },
    "adjustment.splits ⇨ 𝑥": {
        "prefix": "adjustment.splits",
        "body": [
            "adjustment.splits$0"
        ],
        "description": "Constant for splits adjustment type (splits adjustment is applied). | TYPE const string"
    },
    "alert.freq_all ⇨ 𝑥": {
        "prefix": "alert.freq_all",
        "body": [
            "alert.freq_all$0"
        ],
        "description": "A named constant for use with the `freq` parameter of the alert() function. All function calls trigger the alert. | TYPE const string"
    },
    "alert.freq_once_per_bar ⇨ 𝑥": {
        "prefix": "alert.freq_once_per_bar",
        "body": [
            "alert.freq_once_per_bar$0"
        ],
        "description": "A named constant for use with the `freq` parameter of the alert() function. The first function call during the bar triggers the alert. | TYPE const string"
    },
    "alert.freq_once_per_bar_close ⇨ 𝑥": {
        "prefix": "alert.freq_once_per_bar_close",
        "body": [
            "alert.freq_once_per_bar_close$0"
        ],
        "description": "A named constant for use with the `freq` parameter of the alert() function. The function call triggers the alert only when it occurs during the last script iteration of the real-time bar, when it closes. | TYPE const string"
    },
    "bar_index ⇨ 𝑥": {
        "prefix": "bar_index",
        "body": [
            "bar_index$0"
        ],
        "description": "Current bar index. Numbering is zero-based, index of the first bar is 0. | TYPE series int"
    },
    "barmerge.gaps_off ⇨ 𝑥": {
        "prefix": "barmerge.gaps_off",
        "body": [
            "barmerge.gaps_off$0"
        ],
        "description": "Merge strategy for requested data. Data is merged continuously without gaps, all the gaps are filled with the previous nearest existing value. | TYPE barmerge_gaps"
    },
    "barmerge.gaps_on ⇨ 𝑥": {
        "prefix": "barmerge.gaps_on",
        "body": [
            "barmerge.gaps_on$0"
        ],
        "description": "Merge strategy for requested data. Data is merged with possible gaps (na values). | TYPE barmerge_gaps"
    },
    "barmerge.lookahead_off ⇨ 𝑥": {
        "prefix": "barmerge.lookahead_off",
        "body": [
            "barmerge.lookahead_off$0"
        ],
        "description": "Merge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their close time. This merge strategy disables effect of getting data from 'future' on calculation on history. | TYPE barmerge_lookahead"
    },
    "barmerge.lookahead_on ⇨ 𝑥": {
        "prefix": "barmerge.lookahead_on",
        "body": [
            "barmerge.lookahead_on$0"
        ],
        "description": "Merge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their opening time. This merge strategy can lead to undesirable effect of getting data from 'future' on calculation on history. This is unacceptable in backtesting strategies, but can be useful in indicators. | TYPE barmerge_lookahead"
    },
    "barstate.isconfirmed ⇨ 𝑥": {
        "prefix": "barstate.isconfirmed",
        "body": [
            "barstate.isconfirmed$0"
        ],
        "description": "Returns true if the script is calculating the last (closing) update of the current bar. The next script calculation will be on the new bar data. | TYPE series bool"
    },
    "barstate.isfirst ⇨ 𝑥": {
        "prefix": "barstate.isfirst",
        "body": [
            "barstate.isfirst$0"
        ],
        "description": "Returns true if current bar is first bar in barset, false otherwise. | TYPE series bool"
    },
    "barstate.ishistory ⇨ 𝑥": {
        "prefix": "barstate.ishistory",
        "body": [
            "barstate.ishistory$0"
        ],
        "description": "Returns true if current bar is a historical bar, false otherwise. | TYPE series bool"
    },
    "barstate.islast ⇨ 𝑥": {
        "prefix": "barstate.islast",
        "body": [
            "barstate.islast$0"
        ],
        "description": "Returns true if current bar is the last bar in barset, false otherwise. This condition is true for all real-time bars in barset. | TYPE series bool"
    },
    "barstate.islastconfirmedhistory ⇨ 𝑥": {
        "prefix": "barstate.islastconfirmedhistory",
        "body": [
            "barstate.islastconfirmedhistory$0"
        ],
        "description": "Returns true if script is executing on the dataset's last bar when market is closed, or script is executing on the bar immediately preceding the real-time bar, if market is open. Returns false otherwise. | TYPE series bool"
    },
    "barstate.isnew ⇨ 𝑥": {
        "prefix": "barstate.isnew",
        "body": [
            "barstate.isnew$0"
        ],
        "description": "Returns true if script is currently calculating on new bar, false otherwise. This variable is true when calculating on historical bars or on first update of a newly generated real-time bar. | TYPE series bool"
    },
    "barstate.isrealtime ⇨ 𝑥": {
        "prefix": "barstate.isrealtime",
        "body": [
            "barstate.isrealtime$0"
        ],
        "description": "Returns true if current bar is a real-time bar, false otherwise. | TYPE series bool"
    },
    "box.all ⇨ 𝑥": {
        "prefix": "box.all",
        "body": [
            "box.all$0"
        ],
        "description": "Returns an array filled with all the current boxes drawn by the script. | TYPE box[]"
    },
    "chart.bg_color ⇨ 𝑥": {
        "prefix": "chart.bg_color",
        "body": [
            "chart.bg_color$0"
        ],
        "description": "Returns the color of the chart's background from the 'Chart settings/Appearance/Background' field. When a gradient is selected, the middle point of the gradient is returned. | TYPE input color"
    },
    "chart.fg_color ⇨ 𝑥": {
        "prefix": "chart.fg_color",
        "body": [
            "chart.fg_color$0"
        ],
        "description": "Returns a color providing optimal contrast with chart.bg_color. | TYPE input color"
    },
    "chart.is_heikinashi ⇨ 𝑥": {
        "prefix": "chart.is_heikinashi",
        "body": [
            "chart.is_heikinashi$0"
        ],
        "description": "Returns true if the chart type is Heikin Ashi, false otherwise. | TYPE simple bool"
    },
    "chart.is_kagi ⇨ 𝑥": {
        "prefix": "chart.is_kagi",
        "body": [
            "chart.is_kagi$0"
        ],
        "description": "Returns true if the chart type is Kagi, false otherwise. | TYPE simple bool"
    },
    "chart.is_linebreak ⇨ 𝑥": {
        "prefix": "chart.is_linebreak",
        "body": [
            "chart.is_linebreak$0"
        ],
        "description": "Returns true if the chart type is Line break, false otherwise. | TYPE simple bool"
    },
    "chart.is_pnf ⇨ 𝑥": {
        "prefix": "chart.is_pnf",
        "body": [
            "chart.is_pnf$0"
        ],
        "description": "Returns true if the chart type is Point & figure, false otherwise. | TYPE simple bool"
    },
    "chart.is_range ⇨ 𝑥": {
        "prefix": "chart.is_range",
        "body": [
            "chart.is_range$0"
        ],
        "description": "Returns true if the chart type is Range, false otherwise. | TYPE simple bool"
    },
    "chart.is_renko ⇨ 𝑥": {
        "prefix": "chart.is_renko",
        "body": [
            "chart.is_renko$0"
        ],
        "description": "Returns true if the chart type is Renko, false otherwise. | TYPE simple bool"
    },
    "chart.is_standard ⇨ 𝑥": {
        "prefix": "chart.is_standard",
        "body": [
            "chart.is_standard$0"
        ],
        "description": "Returns true if the chart type is bars, candles, hollow candles, line, area or baseline, false otherwise. | TYPE simple bool"
    },
    "chart.left_visible_bar_time ⇨ 𝑥": {
        "prefix": "chart.left_visible_bar_time",
        "body": [
            "chart.left_visible_bar_time$0"
        ],
        "description": "The time of the leftmost bar currently visible on the chart. | TYPE input int"
    },
    "chart.right_visible_bar_time ⇨ 𝑥": {
        "prefix": "chart.right_visible_bar_time",
        "body": [
            "chart.right_visible_bar_time$0"
        ],
        "description": "The time of the rightmost bar currently visible on the chart. | TYPE input int"
    },
    "close ⇨ 𝑥": {
        "prefix": "close",
        "body": [
            "close$0"
        ],
        "description": "Close price of the current bar when it has closed, or last traded price of a yet incomplete, realtime bar. | TYPE series float"
    },
    "color.aqua ⇨ 𝑥": {
        "prefix": "color.aqua",
        "body": [
            "color.aqua$0"
        ],
        "description": "Is a named constant for #00BCD4 color. | TYPE const color"
    },
    "color.black ⇨ 𝑥": {
        "prefix": "color.black",
        "body": [
            "color.black$0"
        ],
        "description": "Is a named constant for #363A45 color. | TYPE const color"
    },
    "color.blue ⇨ 𝑥": {
        "prefix": "color.blue",
        "body": [
            "color.blue$0"
        ],
        "description": "Is a named constant for #2962ff color. | TYPE const color"
    },
    "color.fuchsia ⇨ 𝑥": {
        "prefix": "color.fuchsia",
        "body": [
            "color.fuchsia$0"
        ],
        "description": "Is a named constant for #E040FB color. | TYPE const color"
    },
    "color.gray ⇨ 𝑥": {
        "prefix": "color.gray",
        "body": [
            "color.gray$0"
        ],
        "description": "Is a named constant for #787B86 color. | TYPE const color"
    },
    "color.green ⇨ 𝑥": {
        "prefix": "color.green",
        "body": [
            "color.green$0"
        ],
        "description": "Is a named constant for #4CAF50 color. | TYPE const color"
    },
    "color.lime ⇨ 𝑥": {
        "prefix": "color.lime",
        "body": [
            "color.lime$0"
        ],
        "description": "Is a named constant for #00E676 color. | TYPE const color"
    },
    "color.maroon ⇨ 𝑥": {
        "prefix": "color.maroon",
        "body": [
            "color.maroon$0"
        ],
        "description": "Is a named constant for #880E4F color. | TYPE const color"
    },
    "color.navy ⇨ 𝑥": {
        "prefix": "color.navy",
        "body": [
            "color.navy$0"
        ],
        "description": "Is a named constant for #311B92 color. | TYPE const color"
    },
    "color.olive ⇨ 𝑥": {
        "prefix": "color.olive",
        "body": [
            "color.olive$0"
        ],
        "description": "Is a named constant for #808000 color. | TYPE const color"
    },
    "color.orange ⇨ 𝑥": {
        "prefix": "color.orange",
        "body": [
            "color.orange$0"
        ],
        "description": "Is a named constant for #FF9800 color. | TYPE const color"
    },
    "color.purple ⇨ 𝑥": {
        "prefix": "color.purple",
        "body": [
            "color.purple$0"
        ],
        "description": "Is a named constant for #9C27B0 color. | TYPE const color"
    },
    "color.red ⇨ 𝑥": {
        "prefix": "color.red",
        "body": [
            "color.red$0"
        ],
        "description": "Is a named constant for #FF5252 color. | TYPE const color"
    },
    "color.silver ⇨ 𝑥": {
        "prefix": "color.silver",
        "body": [
            "color.silver$0"
        ],
        "description": "Is a named constant for #B2B5BE color. | TYPE const color"
    },
    "color.teal ⇨ 𝑥": {
        "prefix": "color.teal",
        "body": [
            "color.teal$0"
        ],
        "description": "Is a named constant for #00897B color. | TYPE const color"
    },
    "color.white ⇨ 𝑥": {
        "prefix": "color.white",
        "body": [
            "color.white$0"
        ],
        "description": "Is a named constant for #FFFFFF color. | TYPE const color"
    },
    "color.yellow ⇨ 𝑥": {
        "prefix": "color.yellow",
        "body": [
            "color.yellow$0"
        ],
        "description": "Is a named constant for #FFEB3B color. | TYPE const color"
    },
    "currency.AUD ⇨ 𝑥": {
        "prefix": "currency.AUD",
        "body": [
            "currency.AUD$0"
        ],
        "description": "Australian dollar. | TYPE const string"
    },
    "currency.BTC ⇨ 𝑥": {
        "prefix": "currency.BTC",
        "body": [
            "currency.BTC$0"
        ],
        "description": "Bitcoin. | TYPE const string"
    },
    "currency.CAD ⇨ 𝑥": {
        "prefix": "currency.CAD",
        "body": [
            "currency.CAD$0"
        ],
        "description": "Canadian dollar. | TYPE const string"
    },
    "currency.CHF ⇨ 𝑥": {
        "prefix": "currency.CHF",
        "body": [
            "currency.CHF$0"
        ],
        "description": "Swiss franc. | TYPE const string"
    },
    "currency.ETH ⇨ 𝑥": {
        "prefix": "currency.ETH",
        "body": [
            "currency.ETH$0"
        ],
        "description": "Ethereum. | TYPE const string"
    },
    "currency.EUR ⇨ 𝑥": {
        "prefix": "currency.EUR",
        "body": [
            "currency.EUR$0"
        ],
        "description": "Euro. | TYPE const string"
    },
    "currency.GBP ⇨ 𝑥": {
        "prefix": "currency.GBP",
        "body": [
            "currency.GBP$0"
        ],
        "description": "Pound sterling. | TYPE const string"
    },
    "currency.HKD ⇨ 𝑥": {
        "prefix": "currency.HKD",
        "body": [
            "currency.HKD$0"
        ],
        "description": "Hong Kong dollar. | TYPE const string"
    },
    "currency.INR ⇨ 𝑥": {
        "prefix": "currency.INR",
        "body": [
            "currency.INR$0"
        ],
        "description": "Indian rupee. | TYPE const string"
    },
    "currency.JPY ⇨ 𝑥": {
        "prefix": "currency.JPY",
        "body": [
            "currency.JPY$0"
        ],
        "description": "Japanese yen. | TYPE const string"
    },
    "currency.KRW ⇨ 𝑥": {
        "prefix": "currency.KRW",
        "body": [
            "currency.KRW$0"
        ],
        "description": "South Korean won. | TYPE const string"
    },
    "currency.MYR ⇨ 𝑥": {
        "prefix": "currency.MYR",
        "body": [
            "currency.MYR$0"
        ],
        "description": "Malaysian ringgit. | TYPE const string"
    },
    "currency.NOK ⇨ 𝑥": {
        "prefix": "currency.NOK",
        "body": [
            "currency.NOK$0"
        ],
        "description": "Norwegian krone. | TYPE const string"
    },
    "currency.NONE ⇨ 𝑥": {
        "prefix": "currency.NONE",
        "body": [
            "currency.NONE$0"
        ],
        "description": "Unspecified currency. | TYPE const string"
    },
    "currency.NZD ⇨ 𝑥": {
        "prefix": "currency.NZD",
        "body": [
            "currency.NZD$0"
        ],
        "description": "New Zealand dollar. | TYPE const string"
    },
    "currency.RUB ⇨ 𝑥": {
        "prefix": "currency.RUB",
        "body": [
            "currency.RUB$0"
        ],
        "description": "Russian ruble. | TYPE const string"
    },
    "currency.SEK ⇨ 𝑥": {
        "prefix": "currency.SEK",
        "body": [
            "currency.SEK$0"
        ],
        "description": "Swedish krona. | TYPE const string"
    },
    "currency.SGD ⇨ 𝑥": {
        "prefix": "currency.SGD",
        "body": [
            "currency.SGD$0"
        ],
        "description": "Singapore dollar. | TYPE const string"
    },
    "currency.TRY ⇨ 𝑥": {
        "prefix": "currency.TRY",
        "body": [
            "currency.TRY$0"
        ],
        "description": "Turkish lira. | TYPE const string"
    },
    "currency.USD ⇨ 𝑥": {
        "prefix": "currency.USD",
        "body": [
            "currency.USD$0"
        ],
        "description": "United States dollar. | TYPE const string"
    },
    "currency.USDT ⇨ 𝑥": {
        "prefix": "currency.USDT",
        "body": [
            "currency.USDT$0"
        ],
        "description": "Tether. | TYPE const string"
    },
    "currency.ZAR ⇨ 𝑥": {
        "prefix": "currency.ZAR",
        "body": [
            "currency.ZAR$0"
        ],
        "description": "South African rand. | TYPE const string"
    },
    "dayofmonth ⇨ 𝑥": {
        "prefix": "dayofmonth",
        "body": [
            "dayofmonth$0"
        ],
        "description": "Date of current bar time in exchange timezone. | TYPE series int"
    },
    "dayofweek ⇨ 𝑥": {
        "prefix": "dayofweek",
        "body": [
            "dayofweek$0"
        ],
        "description": "Day of week for current bar time in exchange timezone. | TYPE series int"
    },
    "dayofweek.friday ⇨ 𝑥": {
        "prefix": "dayofweek.friday",
        "body": [
            "dayofweek.friday$0"
        ],
        "description": "Is a named constant for return value of dayofweek function and value of dayofweek variable. | TYPE const int"
    },
    "dayofweek.monday ⇨ 𝑥": {
        "prefix": "dayofweek.monday",
        "body": [
            "dayofweek.monday$0"
        ],
        "description": "Is a named constant for return value of dayofweek function and value of dayofweek variable. | TYPE const int"
    },
    "dayofweek.saturday ⇨ 𝑥": {
        "prefix": "dayofweek.saturday",
        "body": [
            "dayofweek.saturday$0"
        ],
        "description": "Is a named constant for return value of dayofweek function and value of dayofweek variable. | TYPE const int"
    },
    "dayofweek.sunday ⇨ 𝑥": {
        "prefix": "dayofweek.sunday",
        "body": [
            "dayofweek.sunday$0"
        ],
        "description": "Is a named constant for return value of dayofweek function and value of dayofweek variable. | TYPE const int"
    },
    "dayofweek.thursday ⇨ 𝑥": {
        "prefix": "dayofweek.thursday",
        "body": [
            "dayofweek.thursday$0"
        ],
        "description": "Is a named constant for return value of dayofweek function and value of dayofweek variable. | TYPE const int"
    },
    "dayofweek.tuesday ⇨ 𝑥": {
        "prefix": "dayofweek.tuesday",
        "body": [
            "dayofweek.tuesday$0"
        ],
        "description": "Is a named constant for return value of dayofweek function and value of dayofweek variable. | TYPE const int"
    },
    "dayofweek.wednesday ⇨ 𝑥": {
        "prefix": "dayofweek.wednesday",
        "body": [
            "dayofweek.wednesday$0"
        ],
        "description": "Is a named constant for return value of dayofweek function and value of dayofweek variable. | TYPE const int"
    },
    "display.all ⇨ 𝑥": {
        "prefix": "display.all",
        "body": [
            "display.all$0"
        ],
        "description": "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions. Displays plotted or input values in all possible locations. | TYPE plot_simple_display"
    },
    "display.data_window ⇨ 𝑥": {
        "prefix": "display.data_window",
        "body": [
            "display.data_window$0"
        ],
        "description": "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions. Displays plotted or input values in the Data Window, a menu accessible from the chart's right sidebar. | TYPE plot_display"
    },
    "display.none ⇨ 𝑥": {
        "prefix": "display.none",
        "body": [
            "display.none$0"
        ],
        "description": "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions. `plot*()` functions using this will not display their plotted values anywhere. However, alert template messages and fill functions can still use the values, and they will appear in exported chart data. `input*()` functions using this constant will only display their values within the script's settings. | TYPE plot_simple_display"
    },
    "display.pane ⇨ 𝑥": {
        "prefix": "display.pane",
        "body": [
            "display.pane$0"
        ],
        "description": "A named constant for use with the `display` parameter of `plot*()` functions. Displays plotted values in the chart pane used by the script. | TYPE plot_display"
    },
    "display.price_scale ⇨ 𝑥": {
        "prefix": "display.price_scale",
        "body": [
            "display.price_scale$0"
        ],
        "description": "A named constant for use with the `display` parameter of `plot*()` functions. Displays the plot’s label and value on the price scale if the chart's settings allow it. | TYPE plot_display"
    },
    "display.status_line ⇨ 𝑥": {
        "prefix": "display.status_line",
        "body": [
            "display.status_line$0"
        ],
        "description": "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions. Displays plotted or input values in the status line next to the script's name on the chart if the chart's settings allow it. | TYPE plot_display"
    },
    "dividends.gross ⇨ 𝑥": {
        "prefix": "dividends.gross",
        "body": [
            "dividends.gross$0"
        ],
        "description": "A named constant for the request.dividends function. Is used to request the dividends return on a stock before deductions. | TYPE const string"
    },
    "dividends.net ⇨ 𝑥": {
        "prefix": "dividends.net",
        "body": [
            "dividends.net$0"
        ],
        "description": "A named constant for the request.dividends function. Is used to request the dividends return on a stock after deductions. | TYPE const string"
    },
    "earnings.actual ⇨ 𝑥": {
        "prefix": "earnings.actual",
        "body": [
            "earnings.actual$0"
        ],
        "description": "A named constant for the request.earnings function. Is used to request the earnings value as it was reported. | TYPE const string"
    },
    "earnings.estimate ⇨ 𝑥": {
        "prefix": "earnings.estimate",
        "body": [
            "earnings.estimate$0"
        ],
        "description": "A named constant for the request.earnings function. Is used to request the estimated earnings value. | TYPE const string"
    },
    "earnings.standardized ⇨ 𝑥": {
        "prefix": "earnings.standardized",
        "body": [
            "earnings.standardized$0"
        ],
        "description": "A named constant for the request.earnings function. Is used to request the standardized earnings value. | TYPE const string"
    },
    "extend.both ⇨ 𝑥": {
        "prefix": "extend.both",
        "body": [
            "extend.both$0"
        ],
        "description": "A named constant for line.new and line.set_extend functions. | TYPE const string"
    },
    "extend.left ⇨ 𝑥": {
        "prefix": "extend.left",
        "body": [
            "extend.left$0"
        ],
        "description": "A named constant for line.new and line.set_extend functions. | TYPE const string"
    },
    "extend.none ⇨ 𝑥": {
        "prefix": "extend.none",
        "body": [
            "extend.none$0"
        ],
        "description": "A named constant for line.new and line.set_extend functions. | TYPE const string"
    },
    "extend.right ⇨ 𝑥": {
        "prefix": "extend.right",
        "body": [
            "extend.right$0"
        ],
        "description": "A named constant for line.new and line.set_extend functions. | TYPE const string"
    },
    "font.family_default ⇨ 𝑥": {
        "prefix": "font.family_default",
        "body": [
            "font.family_default$0"
        ],
        "description": "Default text font for box.new, box.set_text_font_family, label.new, label.set_text_font_family, table.cell and table.cell_set_text_font_family functions. | TYPE const string"
    },
    "font.family_monospace ⇨ 𝑥": {
        "prefix": "font.family_monospace",
        "body": [
            "font.family_monospace$0"
        ],
        "description": "Monospace text font for box.new, box.set_text_font_family, label.new, label.set_text_font_family, table.cell and table.cell_set_text_font_family functions. | TYPE const string"
    },
    "format.inherit ⇨ 𝑥": {
        "prefix": "format.inherit",
        "body": [
            "format.inherit$0"
        ],
        "description": "Is a named constant for selecting the formatting of the script output values from the parent series in the indicator function. | TYPE const string"
    },
    "format.mintick ⇨ 𝑥": {
        "prefix": "format.mintick",
        "body": [
            "format.mintick$0"
        ],
        "description": "Is a named constant to use with the str.tostring function. Passing a number to str.tostring with this argument rounds the number to the nearest value that can be divided by syminfo.mintick, without the remainder, with ties rounding up, and returns the string version of said value with trailing zeroes. | TYPE const string"
    },
    "format.percent ⇨ 𝑥": {
        "prefix": "format.percent",
        "body": [
            "format.percent$0"
        ],
        "description": "Is a named constant for selecting the formatting of the script output values as a percentage in the indicator function. It adds a percent sign after values. | TYPE const string"
    },
    "format.price ⇨ 𝑥": {
        "prefix": "format.price",
        "body": [
            "format.price$0"
        ],
        "description": "Is a named constant for selecting the formatting of the script output values as prices in the indicator function. | TYPE const string"
    },
    "format.volume ⇨ 𝑥": {
        "prefix": "format.volume",
        "body": [
            "format.volume$0"
        ],
        "description": "Is a named constant for selecting the formatting of the script output values as volume in the indicator function, e.g. '5183' will be formatted as '5.183K'. | TYPE const string"
    },
    "high ⇨ 𝑥": {
        "prefix": "high",
        "body": [
            "high$0"
        ],
        "description": "Current high price. | TYPE series float"
    },
    "hl2 ⇨ 𝑥": {
        "prefix": "hl2",
        "body": [
            "hl2$0"
        ],
        "description": "Is a shortcut for (high + low)/2 | TYPE series float"
    },
    "hlc3 ⇨ 𝑥": {
        "prefix": "hlc3",
        "body": [
            "hlc3$0"
        ],
        "description": "Is a shortcut for (high + low + close)/3 | TYPE series float"
    },
    "hlcc4 ⇨ 𝑥": {
        "prefix": "hlcc4",
        "body": [
            "hlcc4$0"
        ],
        "description": "Is a shortcut for (high + low + close + close)/4 | TYPE series float"
    },
    "hline.style_dashed ⇨ 𝑥": {
        "prefix": "hline.style_dashed",
        "body": [
            "hline.style_dashed$0"
        ],
        "description": "Is a named constant for dashed linestyle of hline function. | TYPE hline_style"
    },
    "hline.style_dotted ⇨ 𝑥": {
        "prefix": "hline.style_dotted",
        "body": [
            "hline.style_dotted$0"
        ],
        "description": "Is a named constant for dotted linestyle of hline function. | TYPE hline_style"
    },
    "hline.style_solid ⇨ 𝑥": {
        "prefix": "hline.style_solid",
        "body": [
            "hline.style_solid$0"
        ],
        "description": "Is a named constant for solid linestyle of hline function. | TYPE hline_style"
    },
    "hour ⇨ 𝑥": {
        "prefix": "hour",
        "body": [
            "hour$0"
        ],
        "description": "Current bar hour in exchange timezone. | TYPE series int"
    },
    "label.all ⇨ 𝑥": {
        "prefix": "label.all",
        "body": [
            "label.all$0"
        ],
        "description": "Returns an array filled with all the current labels drawn by the script. | TYPE label[]"
    },
    "label.style_arrowdown ⇨ 𝑥": {
        "prefix": "label.style_arrowdown",
        "body": [
            "label.style_arrowdown$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_arrowup ⇨ 𝑥": {
        "prefix": "label.style_arrowup",
        "body": [
            "label.style_arrowup$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_circle ⇨ 𝑥": {
        "prefix": "label.style_circle",
        "body": [
            "label.style_circle$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_cross ⇨ 𝑥": {
        "prefix": "label.style_cross",
        "body": [
            "label.style_cross$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_diamond ⇨ 𝑥": {
        "prefix": "label.style_diamond",
        "body": [
            "label.style_diamond$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_flag ⇨ 𝑥": {
        "prefix": "label.style_flag",
        "body": [
            "label.style_flag$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_label_center ⇨ 𝑥": {
        "prefix": "label.style_label_center",
        "body": [
            "label.style_label_center$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_label_down ⇨ 𝑥": {
        "prefix": "label.style_label_down",
        "body": [
            "label.style_label_down$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_label_left ⇨ 𝑥": {
        "prefix": "label.style_label_left",
        "body": [
            "label.style_label_left$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_label_lower_left ⇨ 𝑥": {
        "prefix": "label.style_label_lower_left",
        "body": [
            "label.style_label_lower_left$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_label_lower_right ⇨ 𝑥": {
        "prefix": "label.style_label_lower_right",
        "body": [
            "label.style_label_lower_right$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_label_right ⇨ 𝑥": {
        "prefix": "label.style_label_right",
        "body": [
            "label.style_label_right$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_label_up ⇨ 𝑥": {
        "prefix": "label.style_label_up",
        "body": [
            "label.style_label_up$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_label_upper_left ⇨ 𝑥": {
        "prefix": "label.style_label_upper_left",
        "body": [
            "label.style_label_upper_left$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_label_upper_right ⇨ 𝑥": {
        "prefix": "label.style_label_upper_right",
        "body": [
            "label.style_label_upper_right$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_none ⇨ 𝑥": {
        "prefix": "label.style_none",
        "body": [
            "label.style_none$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_square ⇨ 𝑥": {
        "prefix": "label.style_square",
        "body": [
            "label.style_square$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_text_outline ⇨ 𝑥": {
        "prefix": "label.style_text_outline",
        "body": [
            "label.style_text_outline$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_triangledown ⇨ 𝑥": {
        "prefix": "label.style_triangledown",
        "body": [
            "label.style_triangledown$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_triangleup ⇨ 𝑥": {
        "prefix": "label.style_triangleup",
        "body": [
            "label.style_triangleup$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "label.style_xcross ⇨ 𝑥": {
        "prefix": "label.style_xcross",
        "body": [
            "label.style_xcross$0"
        ],
        "description": "Label style for label.new and label.set_style functions. | TYPE const string"
    },
    "last_bar_index ⇨ 𝑥": {
        "prefix": "last_bar_index",
        "body": [
            "last_bar_index$0"
        ],
        "description": "Bar index of the last chart bar. Bar indices begin at zero on the first bar. | TYPE series int"
    },
    "last_bar_time ⇨ 𝑥": {
        "prefix": "last_bar_time",
        "body": [
            "last_bar_time$0"
        ],
        "description": "Time in UNIX format of the last chart bar. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. | TYPE series int"
    },
    "line.all ⇨ 𝑥": {
        "prefix": "line.all",
        "body": [
            "line.all$0"
        ],
        "description": "Returns an array filled with all the current lines drawn by the script. | TYPE line[]"
    },
    "line.style_arrow_both ⇨ 𝑥": {
        "prefix": "line.style_arrow_both",
        "body": [
            "line.style_arrow_both$0"
        ],
        "description": "Line style for line.new and line.set_style functions. Solid line with arrows on both points. | TYPE const string"
    },
    "line.style_arrow_left ⇨ 𝑥": {
        "prefix": "line.style_arrow_left",
        "body": [
            "line.style_arrow_left$0"
        ],
        "description": "Line style for line.new and line.set_style functions. Solid line with arrow on the first point. | TYPE const string"
    },
    "line.style_arrow_right ⇨ 𝑥": {
        "prefix": "line.style_arrow_right",
        "body": [
            "line.style_arrow_right$0"
        ],
        "description": "Line style for line.new and line.set_style functions. Solid line with arrow on the second point. | TYPE const string"
    },
    "line.style_dashed ⇨ 𝑥": {
        "prefix": "line.style_dashed",
        "body": [
            "line.style_dashed$0"
        ],
        "description": "Line style for line.new and line.set_style functions. | TYPE const string"
    },
    "line.style_dotted ⇨ 𝑥": {
        "prefix": "line.style_dotted",
        "body": [
            "line.style_dotted$0"
        ],
        "description": "Line style for line.new and line.set_style functions. | TYPE const string"
    },
    "line.style_solid ⇨ 𝑥": {
        "prefix": "line.style_solid",
        "body": [
            "line.style_solid$0"
        ],
        "description": "Line style for line.new and line.set_style functions. | TYPE const string"
    },
    "linefill.all ⇨ 𝑥": {
        "prefix": "linefill.all",
        "body": [
            "linefill.all$0"
        ],
        "description": "Returns an array filled with all the current linefill objects drawn by the script. | TYPE linefill[]"
    },
    "location.abovebar ⇨ 𝑥": {
        "prefix": "location.abovebar",
        "body": [
            "location.abovebar$0"
        ],
        "description": "Location value for plotshape, plotchar functions. Shape is plotted above main series bars. | TYPE const string"
    },
    "location.absolute ⇨ 𝑥": {
        "prefix": "location.absolute",
        "body": [
            "location.absolute$0"
        ],
        "description": "Location value for plotshape, plotchar functions. Shape is plotted on chart using indicator value as a price coordinate. | TYPE const string"
    },
    "location.belowbar ⇨ 𝑥": {
        "prefix": "location.belowbar",
        "body": [
            "location.belowbar$0"
        ],
        "description": "Location value for plotshape, plotchar functions. Shape is plotted below main series bars. | TYPE const string"
    },
    "location.bottom ⇨ 𝑥": {
        "prefix": "location.bottom",
        "body": [
            "location.bottom$0"
        ],
        "description": "Location value for plotshape, plotchar functions. Shape is plotted near the bottom chart border. | TYPE const string"
    },
    "location.top ⇨ 𝑥": {
        "prefix": "location.top",
        "body": [
            "location.top$0"
        ],
        "description": "Location value for plotshape, plotchar functions. Shape is plotted near the top chart border. | TYPE const string"
    },
    "low ⇨ 𝑥": {
        "prefix": "low",
        "body": [
            "low$0"
        ],
        "description": "Current low price. | TYPE series float"
    },
    "math.e ⇨ 𝑥": {
        "prefix": "math.e",
        "body": [
            "math.e$0"
        ],
        "description": "Is a named constant for Euler's number). It is equal to 2.7182818284590452. | TYPE const float"
    },
    "math.phi ⇨ 𝑥": {
        "prefix": "math.phi",
        "body": [
            "math.phi$0"
        ],
        "description": "Is a named constant for the golden ratio. It is equal to 1.6180339887498948. | TYPE const float"
    },
    "math.pi ⇨ 𝑥": {
        "prefix": "math.pi",
        "body": [
            "math.pi$0"
        ],
        "description": "Is a named constant for Archimedes' constant. It is equal to 3.1415926535897932. | TYPE const float"
    },
    "math.rphi ⇨ 𝑥": {
        "prefix": "math.rphi",
        "body": [
            "math.rphi$0"
        ],
        "description": "Is a named constant for the golden ratio conjugate. It is equal to 0.6180339887498948. | TYPE const float"
    },
    "minute ⇨ 𝑥": {
        "prefix": "minute",
        "body": [
            "minute$0"
        ],
        "description": "Current bar minute in exchange timezone. | TYPE series int"
    },
    "month ⇨ 𝑥": {
        "prefix": "month",
        "body": [
            "month$0"
        ],
        "description": "Current bar month in exchange timezone. | TYPE series int"
    },
    "na ⇨ 𝑥": {
        "prefix": "na",
        "body": [
            "na$0"
        ],
        "description": "A keyword signifying 'not available', indicating that a variable has no assigned value. | TYPE simple na"
    },
    "ohlc4 ⇨ 𝑥": {
        "prefix": "ohlc4",
        "body": [
            "ohlc4$0"
        ],
        "description": "Is a shortcut for (open + high + low + close)/4 | TYPE series float"
    },
    "open ⇨ 𝑥": {
        "prefix": "open",
        "body": [
            "open$0"
        ],
        "description": "Current open price. | TYPE series float"
    },
    "order.ascending ⇨ 𝑥": {
        "prefix": "order.ascending",
        "body": [
            "order.ascending$0"
        ],
        "description": "Determines the sort order of the array from the smallest to the largest value. | TYPE sort_order"
    },
    "order.descending ⇨ 𝑥": {
        "prefix": "order.descending",
        "body": [
            "order.descending$0"
        ],
        "description": "Determines the sort order of the array from the largest to the smallest value. | TYPE sort_order"
    },
    "plot.style_area ⇨ 𝑥": {
        "prefix": "plot.style_area",
        "body": [
            "plot.style_area$0"
        ],
        "description": "A named constant for the 'Area' style, to be used as an argument for the `style` parameter in the plot function. | TYPE plot_style"
    },
    "plot.style_areabr ⇨ 𝑥": {
        "prefix": "plot.style_areabr",
        "body": [
            "plot.style_areabr$0"
        ],
        "description": "A named constant for the 'Area With Breaks' style, to be used as an argument for the `style` parameter in the plot function. Similar to plot.style_area, except the gaps in the data are not filled. | TYPE plot_style"
    },
    "plot.style_circles ⇨ 𝑥": {
        "prefix": "plot.style_circles",
        "body": [
            "plot.style_circles$0"
        ],
        "description": "A named constant for the 'Circles' style, to be used as an argument for the `style` parameter in the plot function. | TYPE plot_style"
    },
    "plot.style_columns ⇨ 𝑥": {
        "prefix": "plot.style_columns",
        "body": [
            "plot.style_columns$0"
        ],
        "description": "A named constant for the 'Columns' style, to be used as an argument for the `style` parameter in the plot function. | TYPE plot_style"
    },
    "plot.style_cross ⇨ 𝑥": {
        "prefix": "plot.style_cross",
        "body": [
            "plot.style_cross$0"
        ],
        "description": "A named constant for the 'Cross' style, to be used as an argument for the `style` parameter in the plot function. | TYPE plot_style"
    },
    "plot.style_histogram ⇨ 𝑥": {
        "prefix": "plot.style_histogram",
        "body": [
            "plot.style_histogram$0"
        ],
        "description": "A named constant for the 'Histogram' style, to be used as an argument for the `style` parameter in the plot function. | TYPE plot_style"
    },
    "plot.style_line ⇨ 𝑥": {
        "prefix": "plot.style_line",
        "body": [
            "plot.style_line$0"
        ],
        "description": "A named constant for the 'Line' style, to be used as an argument for the `style` parameter in the plot function. | TYPE plot_style"
    },
    "plot.style_linebr ⇨ 𝑥": {
        "prefix": "plot.style_linebr",
        "body": [
            "plot.style_linebr$0"
        ],
        "description": "A named constant for the 'Line With Breaks' style, to be used as an argument for the `style` parameter in the plot function. Similar to plot.style_line, except the gaps in the data are not filled. | TYPE plot_style"
    },
    "plot.style_stepline ⇨ 𝑥": {
        "prefix": "plot.style_stepline",
        "body": [
            "plot.style_stepline$0"
        ],
        "description": "A named constant for the 'Step Line' style, to be used as an argument for the `style` parameter in the plot function. | TYPE plot_style"
    },
    "plot.style_stepline_diamond ⇨ 𝑥": {
        "prefix": "plot.style_stepline_diamond",
        "body": [
            "plot.style_stepline_diamond$0"
        ],
        "description": "A named constant for the 'Step Line With Diamonds' style, to be used as an argument for the `style` parameter in the plot function. Similar to plot.style_stepline, except the data changes are also marked with the Diamond shapes. | TYPE plot_style"
    },
    "plot.style_steplinebr ⇨ 𝑥": {
        "prefix": "plot.style_steplinebr",
        "body": [
            "plot.style_steplinebr$0"
        ],
        "description": "A named constant for the 'Step line with Breaks' style, to be used as an argument for the `style` parameter in the plot function. | TYPE plot_style"
    },
    "position.bottom_center ⇨ 𝑥": {
        "prefix": "position.bottom_center",
        "body": [
            "position.bottom_center$0"
        ],
        "description": "Table position is used in table.new, table.cell functions. Binds the table to the bottom edge in the center. | TYPE const string"
    },
    "position.bottom_left ⇨ 𝑥": {
        "prefix": "position.bottom_left",
        "body": [
            "position.bottom_left$0"
        ],
        "description": "Table position is used in table.new, table.cell functions. Binds the table to the bottom left of the screen. | TYPE const string"
    },
    "position.bottom_right ⇨ 𝑥": {
        "prefix": "position.bottom_right",
        "body": [
            "position.bottom_right$0"
        ],
        "description": "Table position is used in table.new, table.cell functions. Binds the table to the bottom right of the screen. | TYPE const string"
    },
    "position.middle_center ⇨ 𝑥": {
        "prefix": "position.middle_center",
        "body": [
            "position.middle_center$0"
        ],
        "description": "Table position is used in table.new, table.cell functions. Binds the table to the center of the screen. | TYPE const string"
    },
    "position.middle_left ⇨ 𝑥": {
        "prefix": "position.middle_left",
        "body": [
            "position.middle_left$0"
        ],
        "description": "Table position is used in table.new, table.cell functions. Binds the table to the left side of the screen. | TYPE const string"
    },
    "position.middle_right ⇨ 𝑥": {
        "prefix": "position.middle_right",
        "body": [
            "position.middle_right$0"
        ],
        "description": "Table position is used in table.new, table.cell functions. Binds the table to the right side of the screen. | TYPE const string"
    },
    "position.top_center ⇨ 𝑥": {
        "prefix": "position.top_center",
        "body": [
            "position.top_center$0"
        ],
        "description": "Table position is used in table.new, table.cell functions. Binds the table to the top edge in the center. | TYPE const string"
    },
    "position.top_left ⇨ 𝑥": {
        "prefix": "position.top_left",
        "body": [
            "position.top_left$0"
        ],
        "description": "Table position is used in table.new, table.cell functions. Binds the table to the upper-left edge. | TYPE const string"
    },
    "position.top_right ⇨ 𝑥": {
        "prefix": "position.top_right",
        "body": [
            "position.top_right$0"
        ],
        "description": "Table position is used in table.new, table.cell functions. Binds the table to the upper-right edge. | TYPE const string"
    },
    "scale.left ⇨ 𝑥": {
        "prefix": "scale.left",
        "body": [
            "scale.left$0"
        ],
        "description": "Scale value for indicator function. Indicator is added to the left price scale. | TYPE scale_type"
    },
    "scale.none ⇨ 𝑥": {
        "prefix": "scale.none",
        "body": [
            "scale.none$0"
        ],
        "description": "Scale value for indicator function. Indicator is added in 'No Scale' mode. Can be used only with 'overlay=true'. | TYPE scale_type"
    },
    "scale.right ⇨ 𝑥": {
        "prefix": "scale.right",
        "body": [
            "scale.right$0"
        ],
        "description": "Scale value for indicator function. Indicator is added to the right price scale. | TYPE scale_type"
    },
    "second ⇨ 𝑥": {
        "prefix": "second",
        "body": [
            "second$0"
        ],
        "description": "Current bar second in exchange timezone. | TYPE series int"
    },
    "session.extended ⇨ 𝑥": {
        "prefix": "session.extended",
        "body": [
            "session.extended$0"
        ],
        "description": "Constant for extended session type (with extended hours data). | TYPE const string"
    },
    "session.isfirstbar ⇨ 𝑥": {
        "prefix": "session.isfirstbar",
        "body": [
            "session.isfirstbar$0"
        ],
        "description": "Returns true if the current bar is the first bar of the day's session, `false` otherwise. If extended session information is used, only returns true on the first bar of the pre-market bars. | TYPE series bool"
    },
    "session.isfirstbar_regular ⇨ 𝑥": {
        "prefix": "session.isfirstbar_regular",
        "body": [
            "session.isfirstbar_regular$0"
        ],
        "description": "Returns true on the first regular session bar of the day, `false` otherwise. The result is the same whether extended session information is used or not. | TYPE series bool"
    },
    "session.islastbar ⇨ 𝑥": {
        "prefix": "session.islastbar",
        "body": [
            "session.islastbar$0"
        ],
        "description": "Returns true if the current bar is the last bar of the day's session, `false` otherwise. If extended session information is used, only returns true on the last bar of the post-market bars. | TYPE series bool"
    },
    "session.islastbar_regular ⇨ 𝑥": {
        "prefix": "session.islastbar_regular",
        "body": [
            "session.islastbar_regular$0"
        ],
        "description": "Returns true on the last regular session bar of the day, `false` otherwise. The result is the same whether extended session information is used or not. | TYPE series bool"
    },
    "session.ismarket ⇨ 𝑥": {
        "prefix": "session.ismarket",
        "body": [
            "session.ismarket$0"
        ],
        "description": "Returns true if the current bar is a part of the regular trading hours (i.e. market hours), false otherwise. | TYPE series bool"
    },
    "session.ispostmarket ⇨ 𝑥": {
        "prefix": "session.ispostmarket",
        "body": [
            "session.ispostmarket$0"
        ],
        "description": "Returns true if the current bar is a part of the post-market, false otherwise. On non-intraday charts always returns false. | TYPE series bool"
    },
    "session.ispremarket ⇨ 𝑥": {
        "prefix": "session.ispremarket",
        "body": [
            "session.ispremarket$0"
        ],
        "description": "Returns true if the current bar is a part of the pre-market, false otherwise. On non-intraday charts always returns false. | TYPE series bool"
    },
    "session.regular ⇨ 𝑥": {
        "prefix": "session.regular",
        "body": [
            "session.regular$0"
        ],
        "description": "Constant for regular session type (no extended hours data). | TYPE const string"
    },
    "shape.arrowdown ⇨ 𝑥": {
        "prefix": "shape.arrowdown",
        "body": [
            "shape.arrowdown$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.arrowup ⇨ 𝑥": {
        "prefix": "shape.arrowup",
        "body": [
            "shape.arrowup$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.circle ⇨ 𝑥": {
        "prefix": "shape.circle",
        "body": [
            "shape.circle$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.cross ⇨ 𝑥": {
        "prefix": "shape.cross",
        "body": [
            "shape.cross$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.diamond ⇨ 𝑥": {
        "prefix": "shape.diamond",
        "body": [
            "shape.diamond$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.flag ⇨ 𝑥": {
        "prefix": "shape.flag",
        "body": [
            "shape.flag$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.labeldown ⇨ 𝑥": {
        "prefix": "shape.labeldown",
        "body": [
            "shape.labeldown$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.labelup ⇨ 𝑥": {
        "prefix": "shape.labelup",
        "body": [
            "shape.labelup$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.square ⇨ 𝑥": {
        "prefix": "shape.square",
        "body": [
            "shape.square$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.triangledown ⇨ 𝑥": {
        "prefix": "shape.triangledown",
        "body": [
            "shape.triangledown$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.triangleup ⇨ 𝑥": {
        "prefix": "shape.triangleup",
        "body": [
            "shape.triangleup$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "shape.xcross ⇨ 𝑥": {
        "prefix": "shape.xcross",
        "body": [
            "shape.xcross$0"
        ],
        "description": "Shape style for plotshape function. | TYPE const string"
    },
    "size.auto ⇨ 𝑥": {
        "prefix": "size.auto",
        "body": [
            "size.auto$0"
        ],
        "description": "Size value for plotshape, plotchar functions. The size of the shape automatically adapts to the size of the bars. | TYPE const string"
    },
    "size.huge ⇨ 𝑥": {
        "prefix": "size.huge",
        "body": [
            "size.huge$0"
        ],
        "description": "Size value for plotshape, plotchar functions. The size of the shape constantly huge. | TYPE const string"
    },
    "size.large ⇨ 𝑥": {
        "prefix": "size.large",
        "body": [
            "size.large$0"
        ],
        "description": "Size value for plotshape, plotchar functions. The size of the shape constantly large. | TYPE const string"
    },
    "size.normal ⇨ 𝑥": {
        "prefix": "size.normal",
        "body": [
            "size.normal$0"
        ],
        "description": "Size value for plotshape, plotchar functions. The size of the shape constantly normal. | TYPE const string"
    },
    "size.small ⇨ 𝑥": {
        "prefix": "size.small",
        "body": [
            "size.small$0"
        ],
        "description": "Size value for plotshape, plotchar functions. The size of the shape constantly small. | TYPE const string"
    },
    "size.tiny ⇨ 𝑥": {
        "prefix": "size.tiny",
        "body": [
            "size.tiny$0"
        ],
        "description": "Size value for plotshape, plotchar functions. The size of the shape constantly tiny. | TYPE const string"
    },
    "splits.denominator ⇨ 𝑥": {
        "prefix": "splits.denominator",
        "body": [
            "splits.denominator$0"
        ],
        "description": "A named constant for the request.splits function. Is used to request the denominator (the number below the line in a fraction) of a splits. | TYPE const string"
    },
    "splits.numerator ⇨ 𝑥": {
        "prefix": "splits.numerator",
        "body": [
            "splits.numerator$0"
        ],
        "description": "A named constant for the request.splits function. Is used to request the numerator (the number above the line in a fraction) of a splits. | TYPE const string"
    },
    "strategy.account_currency ⇨ 𝑥": {
        "prefix": "strategy.account_currency",
        "body": [
            "strategy.account_currency$0"
        ],
        "description": "Returns the currency used to calculate results, which can be set in the strategy's properties. | TYPE simple string"
    },
    "strategy.cash ⇨ 𝑥": {
        "prefix": "strategy.cash",
        "body": [
            "strategy.cash$0"
        ],
        "description": "This is one of the arguments that can be supplied to the `default_qty_type` parameter in the strategy declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in strategy.entry or strategy.order function calls. It specifies that an amount of cash in the `strategy.account_currency` will be used to enter trades. | TYPE const string"
    },
    "strategy.closedtrades ⇨ 𝑥": {
        "prefix": "strategy.closedtrades",
        "body": [
            "strategy.closedtrades$0"
        ],
        "description": "Number of trades, which were closed for the whole trading interval. | TYPE series int"
    },
    "strategy.commission.cash_per_contract ⇨ 𝑥": {
        "prefix": "strategy.commission.cash_per_contract",
        "body": [
            "strategy.commission.cash_per_contract$0"
        ],
        "description": "Commission type for an order. Money displayed in the account currency per contract. | TYPE const string"
    },
    "strategy.commission.cash_per_order ⇨ 𝑥": {
        "prefix": "strategy.commission.cash_per_order",
        "body": [
            "strategy.commission.cash_per_order$0"
        ],
        "description": "Commission type for an order. Money displayed in the account currency per order. | TYPE const string"
    },
    "strategy.commission.percent ⇨ 𝑥": {
        "prefix": "strategy.commission.percent",
        "body": [
            "strategy.commission.percent$0"
        ],
        "description": "Commission type for an order. A percentage of the cash volume of order. | TYPE const string"
    },
    "strategy.direction.all ⇨ 𝑥": {
        "prefix": "strategy.direction.all",
        "body": [
            "strategy.direction.all$0"
        ],
        "description": "It allows strategy to open both long and short positions. | TYPE const string"
    },
    "strategy.direction.long ⇨ 𝑥": {
        "prefix": "strategy.direction.long",
        "body": [
            "strategy.direction.long$0"
        ],
        "description": "It allows strategy to open only long positions. | TYPE const string"
    },
    "strategy.direction.short ⇨ 𝑥": {
        "prefix": "strategy.direction.short",
        "body": [
            "strategy.direction.short$0"
        ],
        "description": "It allows strategy to open only short positions. | TYPE const string"
    },
    "strategy.equity ⇨ 𝑥": {
        "prefix": "strategy.equity",
        "body": [
            "strategy.equity$0"
        ],
        "description": "Current equity (strategy.initial_capital + strategy.netprofit + strategy.openprofit). | TYPE series float"
    },
    "strategy.eventrades ⇨ 𝑥": {
        "prefix": "strategy.eventrades",
        "body": [
            "strategy.eventrades$0"
        ],
        "description": "Number of breakeven trades for the whole trading interval. | TYPE series int"
    },
    "strategy.fixed ⇨ 𝑥": {
        "prefix": "strategy.fixed",
        "body": [
            "strategy.fixed$0"
        ],
        "description": "This is one of the arguments that can be supplied to the `default_qty_type` parameter in the strategy declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in strategy.entry or strategy.order function calls. It specifies that a number of contracts/shares/lots will be used to enter trades. | TYPE const string"
    },
    "strategy.grossloss ⇨ 𝑥": {
        "prefix": "strategy.grossloss",
        "body": [
            "strategy.grossloss$0"
        ],
        "description": "Total currency value of all completed losing trades. | TYPE series float"
    },
    "strategy.grossprofit ⇨ 𝑥": {
        "prefix": "strategy.grossprofit",
        "body": [
            "strategy.grossprofit$0"
        ],
        "description": "Total currency value of all completed winning trades. | TYPE series float"
    },
    "strategy.initial_capital ⇨ 𝑥": {
        "prefix": "strategy.initial_capital",
        "body": [
            "strategy.initial_capital$0"
        ],
        "description": "The amount of initial capital set in the strategy properties. | TYPE series float"
    },
    "strategy.long ⇨ 𝑥": {
        "prefix": "strategy.long",
        "body": [
            "strategy.long$0"
        ],
        "description": "Long position entry. | TYPE strategy_direction"
    },
    "strategy.losstrades ⇨ 𝑥": {
        "prefix": "strategy.losstrades",
        "body": [
            "strategy.losstrades$0"
        ],
        "description": "Number of unprofitable trades for the whole trading interval. | TYPE series int"
    },
    "strategy.max_contracts_held_all ⇨ 𝑥": {
        "prefix": "strategy.max_contracts_held_all",
        "body": [
            "strategy.max_contracts_held_all$0"
        ],
        "description": "Maximum number of contracts/shares/lots/units in one trade for the whole trading interval. | TYPE series float"
    },
    "strategy.max_contracts_held_long ⇨ 𝑥": {
        "prefix": "strategy.max_contracts_held_long",
        "body": [
            "strategy.max_contracts_held_long$0"
        ],
        "description": "Maximum number of contracts/shares/lots/units in one long trade for the whole trading interval. | TYPE series float"
    },
    "strategy.max_contracts_held_short ⇨ 𝑥": {
        "prefix": "strategy.max_contracts_held_short",
        "body": [
            "strategy.max_contracts_held_short$0"
        ],
        "description": "Maximum number of contracts/shares/lots/units in one short trade for the whole trading interval. | TYPE series float"
    },
    "strategy.max_drawdown ⇨ 𝑥": {
        "prefix": "strategy.max_drawdown",
        "body": [
            "strategy.max_drawdown$0"
        ],
        "description": "Maximum equity drawdown value for the whole trading interval. | TYPE series float"
    },
    "strategy.max_runup ⇨ 𝑥": {
        "prefix": "strategy.max_runup",
        "body": [
            "strategy.max_runup$0"
        ],
        "description": "Maximum equity run-up value for the whole trading interval. | TYPE series float"
    },
    "strategy.netprofit ⇨ 𝑥": {
        "prefix": "strategy.netprofit",
        "body": [
            "strategy.netprofit$0"
        ],
        "description": "Total currency value of all completed trades. | TYPE series float"
    },
    "strategy.oca.cancel ⇨ 𝑥": {
        "prefix": "strategy.oca.cancel",
        "body": [
            "strategy.oca.cancel$0"
        ],
        "description": "OCA type value for strategy's functions. The parameter determines that an order should belong to an OCO group, where as soon as an order is filled, all other orders of the same group are cancelled. Note: if more than 1 guaranteed-to-be-executed orders of the same OCA group are placed at once, all those orders are filled. | TYPE const string"
    },
    "strategy.oca.none ⇨ 𝑥": {
        "prefix": "strategy.oca.none",
        "body": [
            "strategy.oca.none$0"
        ],
        "description": "OCA type value for strategy's functions. The parameter determines that an order should not belong to any particular OCO group. | TYPE const string"
    },
    "strategy.oca.reduce ⇨ 𝑥": {
        "prefix": "strategy.oca.reduce",
        "body": [
            "strategy.oca.reduce$0"
        ],
        "description": "OCA type value for strategy's functions. The parameter determines that an order should belong to an OCO group, where if X number of contracts of an order is filled, number of contracts for each other order of the same OCO group is decreased by X. Note: if more than 1 guaranteed-to-be-executed orders of the same OCA group are placed at once, all those orders are filled. | TYPE const string"
    },
    "strategy.openprofit ⇨ 𝑥": {
        "prefix": "strategy.openprofit",
        "body": [
            "strategy.openprofit$0"
        ],
        "description": "Current unrealized profit or loss for all open positions. | TYPE series float"
    },
    "strategy.opentrades ⇨ 𝑥": {
        "prefix": "strategy.opentrades",
        "body": [
            "strategy.opentrades$0"
        ],
        "description": "Number of market position entries, which were not closed and remain opened. If there is no open market position, 0 is returned. | TYPE series int"
    },
    "strategy.percent_of_equity ⇨ 𝑥": {
        "prefix": "strategy.percent_of_equity",
        "body": [
            "strategy.percent_of_equity$0"
        ],
        "description": "This is one of the arguments that can be supplied to the `default_qty_type` parameter in the strategy declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in strategy.entry or strategy.order function calls. It specifies that a percentage (0-100) of equity will be used to enter trades. | TYPE const string"
    },
    "strategy.position_avg_price ⇨ 𝑥": {
        "prefix": "strategy.position_avg_price",
        "body": [
            "strategy.position_avg_price$0"
        ],
        "description": "Average entry price of current market position. If the market position is flat, 'NaN' is returned. | TYPE series float"
    },
    "strategy.position_entry_name ⇨ 𝑥": {
        "prefix": "strategy.position_entry_name",
        "body": [
            "strategy.position_entry_name$0"
        ],
        "description": "Name of the order that initially opened current market position. | TYPE series string"
    },
    "strategy.position_size ⇨ 𝑥": {
        "prefix": "strategy.position_size",
        "body": [
            "strategy.position_size$0"
        ],
        "description": "Direction and size of the current market position. If the value is > 0, the market position is long. If the value is < 0, the market position is short. The absolute value is the number of contracts/shares/lots/units in trade (position size). | TYPE series float"
    },
    "strategy.short ⇨ 𝑥": {
        "prefix": "strategy.short",
        "body": [
            "strategy.short$0"
        ],
        "description": "Short position entry. | TYPE strategy_direction"
    },
    "strategy.wintrades ⇨ 𝑥": {
        "prefix": "strategy.wintrades",
        "body": [
            "strategy.wintrades$0"
        ],
        "description": "Number of profitable trades for the whole trading interval. | TYPE series int"
    },
    "syminfo.basecurrency ⇨ 𝑥": {
        "prefix": "syminfo.basecurrency",
        "body": [
            "syminfo.basecurrency$0"
        ],
        "description": "Base currency for the symbol. For the symbol 'BTCUSD' returns 'BTC'. | TYPE simple string"
    },
    "syminfo.country ⇨ 𝑥": {
        "prefix": "syminfo.country",
        "body": [
            "syminfo.country$0"
        ],
        "description": "Returns the two-letter code of the country where the symbol is traded, in the ISO 3166-1 alpha-2 format, or na if the exchange is not directly tied to a specific country. For example, on 'NASDAQ:AAPL' it will return 'US', on 'LSE:AAPL' it will return 'GB', and on 'BITSTAMP:BTCUSD' it will return na. | TYPE simple string"
    },
    "syminfo.currency ⇨ 𝑥": {
        "prefix": "syminfo.currency",
        "body": [
            "syminfo.currency$0"
        ],
        "description": "Currency for the current symbol. Returns currency code: 'USD', 'EUR', etc. | TYPE simple string"
    },
    "syminfo.description ⇨ 𝑥":  {
        "prefix": "syminfo.description",
        "body": [
            "syminfo.description$0"
        ],
        "description": "Description for the current symbol. | TYPE simple string"
    },
    "syminfo.industry ⇨ 𝑥":  {
        "prefix": "syminfo.industry",
        "body": [
            "syminfo.industry$0"
        ],
        "description": "Returns the industry of the symbol, or na if the symbol has no industry. Example: 'Internet Software/Services', 'Packaged software', 'Integrated Oil', 'Motor Vehicles', etc. These are the same values one can see in the chart's 'Symbol info' window. | TYPE simple string"
    },
    "syminfo.mintick ⇨ 𝑥": {
        "prefix": "syminfo.mintick",
        "body": [
            "syminfo.mintick$0"
        ],
        "description": "Min tick value for the current symbol. | TYPE simple float"
    },
    "syminfo.pointvalue ⇨ 𝑥": {
        "prefix": "syminfo.pointvalue",
        "body": [
            "syminfo.pointvalue$0"
        ],
        "description": "Point value for the current symbol. | TYPE simple float"
    },
    "syminfo.prefix ⇨ 𝑥": {
        "prefix": "syminfo.prefix",
        "body": [
            "syminfo.prefix$0"
        ],
        "description": "Prefix of current symbol name (i.e. for 'CME_EOD:TICKER' prefix is 'CME_EOD'). | TYPE simple string"
    },
    "syminfo.root ⇨ 𝑥": {
        "prefix": "syminfo.root",
        "body": [
            "syminfo.root$0"
        ],
        "description": "Root for derivatives like futures contract. For other symbols returns the same value as syminfo.ticker. | TYPE simple string"
    },
    "syminfo.sector ⇨ 𝑥": {
        "prefix": "syminfo.sector",
        "body": [
            "syminfo.sector$0"
        ],
        "description": "Returns the sector of the symbol, or na if the symbol has no sector. Example: 'Electronic Technology', 'Technology services', 'Energy Minerals', 'Consumer Durables', etc. These are the same values one can see in the chart's 'Symbol info' window. | TYPE simple string"
    },
    "syminfo.session ⇨ 𝑥": {
        "prefix": "syminfo.session",
        "body": [
            "syminfo.session$0"
        ],
        "description": "Session type of the chart main series. Possible values are session.regular, session.extended. | TYPE simple string"
    },
    "syminfo.ticker ⇨ 𝑥": {
        "prefix": "syminfo.ticker",
        "body": [
            "syminfo.ticker$0"
        ],
        "description": "Symbol name without exchange prefix, e.g. 'MSFT'. | TYPE simple string"
    },
    "syminfo.tickerid ⇨ 𝑥": {
        "prefix": "syminfo.tickerid",
        "body": [
            "syminfo.tickerid$0"
        ],
        "description": "Returns the full form of the ticker ID representing a symbol, for use as an argument in functions with a `ticker` or `symbol` parameter. It always includes the prefix (exchange) and ticker separated by a colon ('NASDAQ:AAPL'), but it can also include other symbol data such as dividend adjustment, chart type, currency conversion, etc. | TYPE simple string"
    },
    "syminfo.timezone ⇨ 𝑥": {
        "prefix": "syminfo.timezone",
        "body": [
            "syminfo.timezone$0"
        ],
        "description": "Timezone of the exchange of the chart main series. Possible values see in timestamp. | TYPE simple string"
    },
    "syminfo.type ⇨ 𝑥": {
        "prefix": "syminfo.type",
        "body": [
            "syminfo.type$0"
        ],
        "description": "Type of the current symbol. Possible values are stock, futures, index, forex, crypto, fund, dr. | TYPE simple string"
    },
    "syminfo.volumetype ⇨ 𝑥": {
        "prefix": "syminfo.volumetype",
        "body": [
            "syminfo.volumetype$0"
        ],
        "description": "Volume type of the current symbol. Possible values are: 'base' for base currency, 'quote' for quote currency, 'tick' for the number of transactions, and 'n/a' when there is no volume or its type is not specified. | TYPE simple string"
    },
    "ta.accdist ⇨ 𝑥": {
        "prefix": "ta.accdist",
        "body": [
            "ta.accdist$0"
        ],
        "description": "Accumulation/distribution index. | TYPE series float"
    },
    "ta.iii ⇨ 𝑥": {
        "prefix": "ta.iii",
        "body": [
            "ta.iii$0"
        ],
        "description": "Intraday Intensity Index. | TYPE series float"
    },
    "ta.nvi ⇨ 𝑥": {
        "prefix": "ta.nvi",
        "body": [
            "ta.nvi$0"
        ],
        "description": "Negative Volume Index. | TYPE series float"
    },
    "ta.obv ⇨ 𝑥": {
        "prefix": "ta.obv",
        "body": [
            "ta.obv$0"
        ],
        "description": "On Balance Volume. | TYPE series float"
    },
    "ta.pvi ⇨ 𝑥": {
        "prefix": "ta.pvi",
        "body": [
            "ta.pvi$0"
        ],
        "description": "Positive Volume Index. | TYPE series float"
    },
    "ta.pvt ⇨ 𝑥": {
        "prefix": "ta.pvt",
        "body": [
            "ta.pvt$0"
        ],
        "description": "Price-Volume Trend. | TYPE series float"
    },
    "ta.tr ⇨ 𝑥": {
        "prefix": "ta.tr",
        "body": [
            "ta.tr$0"
        ],
        "description": "True range. Same as tr(false). It is max(high - low, abs(high - close[1]), abs(low - close[1])) | TYPE series float"
    },
    "ta.vwap ⇨ 𝑥": {
        "prefix": "ta.vwap",
        "body": [
            "ta.vwap$0"
        ],
        "description": "Volume Weighted Average Price. It uses hlc3 as its source series. | TYPE series float"
    },
    "ta.wad ⇨ 𝑥": {
        "prefix": "ta.wad",
        "body": [
            "ta.wad$0"
        ],
        "description": "Williams Accumulation/Distribution. | TYPE series float"
    },
    "ta.wvad ⇨ 𝑥": {
        "prefix": "ta.wvad",
        "body": [
            "ta.wvad$0"
        ],
        "description": "Williams Variable Accumulation/Distribution. | TYPE series float"
    },
    "table.all ⇨ 𝑥": {
        "prefix": "table.all",
        "body": [
            "table.all$0"
        ],
        "description": "Returns an array filled with all the current tables drawn by the script. | TYPE table[]"
    },
    "text.align_bottom ⇨ 𝑥": {
        "prefix": "text.align_bottom",
        "body": [
            "text.align_bottom$0"
        ],
        "description": "Vertical text alignment for box.new, box.set_text_valign, table.cell and table.cell_set_text_valign functions. | TYPE const string"
    },
    "text.align_center ⇨ 𝑥": {
        "prefix": "text.align_center",
        "body": [
            "text.align_center$0"
        ],
        "description": "Text alignment for box.new, box.set_text_halign, box.set_text_valign, label.new and label.set_textalign functions. | TYPE const string"
    },
    "text.align_left ⇨ 𝑥": {
        "prefix": "text.align_left",
        "body": [
            "text.align_left$0"
        ],
        "description": "Horizontal text alignment for box.new, box.set_text_halign, label.new and label.set_textalign functions. | TYPE const string"
    },
    "text.align_right ⇨ 𝑥": {
        "prefix": "text.align_right",
        "body": [
            "text.align_right$0"
        ],
        "description": "Horizontal text alignment for box.new, box.set_text_halign, label.new and label.set_textalign functions. | TYPE const string"
    },
    "text.align_top ⇨ 𝑥": {
        "prefix": "text.align_top",
        "body": [
            "text.align_top$0"
        ],
        "description": "Vertical text alignment for box.new, box.set_text_valign, table.cell and table.cell_set_text_valign functions. | TYPE const string"
    },
    "text.wrap_auto ⇨ 𝑥": {
        "prefix": "text.wrap_auto",
        "body": [
            "text.wrap_auto$0"
        ],
        "description": "Automatic wrapping mode for box.new and box.set_text_wrap functions. | TYPE const string"
    },
    "text.wrap_none ⇨ 𝑥": {
        "prefix": "text.wrap_none",
        "body": [
            "text.wrap_none$0"
        ],
        "description": "Disabled wrapping mode for box.new and box.set_text_wrap functions. | TYPE const string"
    },
    "time ⇨ 𝑥": {
        "prefix": "time",
        "body": [
            "time$0"
        ],
        "description": "Current bar time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. | TYPE series int"
    },
    "time_close ⇨ 𝑥": {
        "prefix": "time_close",
        "body": [
            "time_close$0"
        ],
        "description": "Current bar close time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. On price-based charts this variable value is na. | TYPE series int"
    },
    "time_tradingday ⇨ 𝑥": {
        "prefix": "time_tradingday",
        "body": [
            "time_tradingday$0"
        ],
        "description": "The beginning time of the trading day the current bar belongs to, in UNIX format (the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970). | TYPE series int"
    },
    "timeframe.isdaily ⇨ 𝑥": {
        "prefix": "timeframe.isdaily",
        "body": [
            "timeframe.isdaily$0"
        ],
        "description": "Returns true if current resolution is a daily resolution, false otherwise. | TYPE simple bool"
    },
    "timeframe.isdwm ⇨ 𝑥": {
        "prefix": "timeframe.isdwm",
        "body": [
            "timeframe.isdwm$0"
        ],
        "description": "Returns true if current resolution is a daily or weekly or monthly resolution, false otherwise. | TYPE simple bool"
    },
    "timeframe.isintraday ⇨ 𝑥": {
        "prefix": "timeframe.isintraday",
        "body": [
            "timeframe.isintraday$0"
        ],
        "description": "Returns true if current resolution is an intraday (minutes or seconds) resolution, false otherwise. | TYPE simple bool"
    },
    "timeframe.isminutes ⇨ 𝑥": {
        "prefix": "timeframe.isminutes",
        "body": [
            "timeframe.isminutes$0"
        ],
        "description": "Returns true if current resolution is a minutes resolution, false otherwise. | TYPE simple bool"
    },
    "timeframe.ismonthly ⇨ 𝑥": {
        "prefix": "timeframe.ismonthly",
        "body": [
            "timeframe.ismonthly$0"
        ],
        "description": "Returns true if current resolution is a monthly resolution, false otherwise. | TYPE simple bool"
    },
    "timeframe.isseconds ⇨ 𝑥": {
        "prefix": "timeframe.isseconds",
        "body": [
            "timeframe.isseconds$0"
        ],
        "description": "Returns true if current resolution is a seconds resolution, false otherwise. | TYPE simple bool"
    },
    "timeframe.isweekly ⇨ 𝑥": {
        "prefix": "timeframe.isweekly",
        "body": [
            "timeframe.isweekly$0"
        ],
        "description": "Returns true if current resolution is a weekly resolution, false otherwise. | TYPE simple bool"
    },
    "timeframe.multiplier ⇨ 𝑥": {
        "prefix": "timeframe.multiplier",
        "body": [
            "timeframe.multiplier$0"
        ],
        "description": "Multiplier of resolution, e.g. '60' - 60, 'D' - 1, '5D' - 5, '12M' - 12. | TYPE simple int"
    },
    "timeframe.period ⇨ 𝑥": {
        "prefix": "timeframe.period",
        "body": [
            "timeframe.period$0"
        ],
        "description": "A string representation of the chart's timeframe. The returned string's format is '[<quantity>][<units>]', where <quantity> and <units> are in some cases absent. <quantity> is the number of units, but it is absent if that number is 1. <unit> is 'S' for seconds, 'D' for days, 'W' for weeks, 'M' for months, but it is absent for minutes. No <unit> exists for hours. The variable will return: '10S' for 10 seconds, '60' for 60 minutes, 'D' for one day, '2W' for two weeks, '3M' for one quarter. Can be used as an argument with any function containing a `timeframe` parameter. | TYPE simple string"
    },
    "timenow ⇨ 𝑥": {
        "prefix": "timenow",
        "body": [
            "timenow$0"
        ],
        "description": "Current time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. | TYPE series int"
    },
    "volume ⇨ 𝑥": {
        "prefix": "volume",
        "body": [
            "volume$0"
        ],
        "description": "Current bar volume. | TYPE series float"
    },
    "weekofyear ⇨ 𝑥": {
        "prefix": "weekofyear",
        "body": [
            "weekofyear$0"
        ],
        "description": "Week number of current bar time in exchange timezone. | TYPE series int"
    },
    "xloc.bar_index ⇨ 𝑥": {
        "prefix": "xloc.bar_index",
        "body": [
            "xloc.bar_index$0"
        ],
        "description": "A named constant that specifies the algorithm of interpretation of x-value in functions line.new and label.new. If xloc = xloc.bar_index, value of x is a bar index. | TYPE const string"
    },
    "xloc.bar_time ⇨ 𝑥": {
        "prefix": "xloc.bar_time",
        "body": [
            "xloc.bar_time$0"
        ],
        "description": "A named constant that specifies the algorithm of interpretation of x-value in functions line.new and label.new. If xloc = xloc.bar_time, value of x is a bar UNIX time. | TYPE const string"
    },
    "year ⇨ 𝑥": {
        "prefix": "year",
        "body": [
            "year$0"
        ],
        "description": "Current bar year in exchange timezone. | TYPE series int"
    },
    "yloc.abovebar ⇨ 𝑥": {
        "prefix": "yloc.abovebar",
        "body": [
            "yloc.abovebar$0"
        ],
        "description": "A named constant that specifies the algorithm of interpretation of y-value in function label.new. | TYPE const string"
    },
    "yloc.belowbar ⇨ 𝑥": {
        "prefix": "yloc.belowbar",
        "body": [
            "yloc.belowbar$0"
        ],
        "description": "A named constant that specifies the algorithm of interpretation of y-value in function label.new. | TYPE const string"
    },
    "yloc.price ⇨ 𝑥": {
        "prefix": "yloc.price",
        "body": [
            "yloc.price$0"
        ],
        "description": "A named constant that specifies the algorithm of interpretation of y-value in function label.new. | TYPE const string"
    }
}